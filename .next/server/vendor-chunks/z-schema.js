/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/z-schema";
exports.ids = ["vendor-chunks/z-schema"];
exports.modules = {

/***/ "(rsc)/./node_modules/z-schema/src/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/z-schema/src/Errors.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n\n    INVALID_TYPE:                           \"Expected type {0} but found type {1}\",\n    INVALID_FORMAT:                         \"Object didn't pass validation for format {0}: {1}\",\n    ENUM_MISMATCH:                          \"No enum match for: {0}\",\n    ENUM_CASE_MISMATCH:                     \"Enum does not match case for: {0}\",\n    ANY_OF_MISSING:                         \"Data does not match any schemas from 'anyOf'\",\n    ONE_OF_MISSING:                         \"Data does not match any schemas from 'oneOf'\",\n    ONE_OF_MULTIPLE:                        \"Data is valid against more than one schema from 'oneOf'\",\n    NOT_PASSED:                             \"Data matches schema from 'not'\",\n\n    // Array errors\n    ARRAY_LENGTH_SHORT:                     \"Array is too short ({0}), minimum {1}\",\n    ARRAY_LENGTH_LONG:                      \"Array is too long ({0}), maximum {1}\",\n    ARRAY_UNIQUE:                           \"Array items are not unique (indexes {0} and {1})\",\n    ARRAY_ADDITIONAL_ITEMS:                 \"Additional items not allowed\",\n\n    // Numeric errors\n    MULTIPLE_OF:                            \"Value {0} is not a multiple of {1}\",\n    MINIMUM:                                \"Value {0} is less than minimum {1}\",\n    MINIMUM_EXCLUSIVE:                      \"Value {0} is equal or less than exclusive minimum {1}\",\n    MAXIMUM:                                \"Value {0} is greater than maximum {1}\",\n    MAXIMUM_EXCLUSIVE:                      \"Value {0} is equal or greater than exclusive maximum {1}\",\n\n    // Object errors\n    OBJECT_PROPERTIES_MINIMUM:              \"Too few properties defined ({0}), minimum {1}\",\n    OBJECT_PROPERTIES_MAXIMUM:              \"Too many properties defined ({0}), maximum {1}\",\n    OBJECT_MISSING_REQUIRED_PROPERTY:       \"Missing required property: {0}\",\n    OBJECT_ADDITIONAL_PROPERTIES:           \"Additional properties not allowed: {0}\",\n    OBJECT_DEPENDENCY_KEY:                  \"Dependency failed - key must exist: {0} (due to key: {1})\",\n\n    // String errors\n    MIN_LENGTH:                             \"String is too short ({0} chars), minimum {1}\",\n    MAX_LENGTH:                             \"String is too long ({0} chars), maximum {1}\",\n    PATTERN:                                \"String does not match pattern {0}: {1}\",\n\n    // Schema validation errors\n    KEYWORD_TYPE_EXPECTED:                  \"Keyword '{0}' is expected to be of type '{1}'\",\n    KEYWORD_UNDEFINED_STRICT:               \"Keyword '{0}' must be defined in strict mode\",\n    KEYWORD_UNEXPECTED:                     \"Keyword '{0}' is not expected to appear in the schema\",\n    KEYWORD_MUST_BE:                        \"Keyword '{0}' must be {1}\",\n    KEYWORD_DEPENDENCY:                     \"Keyword '{0}' requires keyword '{1}'\",\n    KEYWORD_PATTERN:                        \"Keyword '{0}' is not a valid RegExp pattern: {1}\",\n    KEYWORD_VALUE_TYPE:                     \"Each element of keyword '{0}' array must be a '{1}'\",\n    UNKNOWN_FORMAT:                         \"There is no validation function for format '{0}'\",\n    CUSTOM_MODE_FORCE_PROPERTIES:           \"{0} must define at least one property if present\",\n\n    // Remote errors\n    REF_UNRESOLVED:                         \"Reference has not been resolved during compilation: {0}\",\n    UNRESOLVABLE_REFERENCE:                 \"Reference could not be resolved: {0}\",\n    SCHEMA_NOT_REACHABLE:                   \"Validator was not able to read schema with uri: {0}\",\n    SCHEMA_TYPE_EXPECTED:                   \"Schema is expected to be of type 'object'\",\n    SCHEMA_NOT_AN_OBJECT:                   \"Schema is not an object: {0}\",\n    ASYNC_TIMEOUT:                          \"{0} asynchronous task(s) have timed out after {1} ms\",\n    PARENT_SCHEMA_VALIDATION_FAILED:        \"Schema failed to validate against its parent schema, see inner errors for details.\",\n    REMOTE_NOT_VALID:                       \"Remote reference didn't compile successfully: {0}\"\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSw0REFBNEQsR0FBRyxnQkFBZ0IsRUFBRTtBQUNqRix1RkFBdUYsRUFBRSxHQUFHLEVBQUU7QUFDOUYsaUVBQWlFLEVBQUU7QUFDbkUsNEVBQTRFLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsRUFBRSxZQUFZLEVBQUU7QUFDbEYsaUVBQWlFLEVBQUUsWUFBWSxFQUFFO0FBQ2pGLGtGQUFrRixHQUFHLEtBQUssRUFBRTtBQUM1Rjs7QUFFQTtBQUNBLG9EQUFvRCxHQUFHLHNCQUFzQixFQUFFO0FBQy9FLG9EQUFvRCxHQUFHLHNCQUFzQixFQUFFO0FBQy9FLG9EQUFvRCxHQUFHLHlDQUF5QyxFQUFFO0FBQ2xHLG9EQUFvRCxHQUFHLHlCQUF5QixFQUFFO0FBQ2xGLG9EQUFvRCxHQUFHLDRDQUE0QyxFQUFFOztBQUVyRztBQUNBLDBFQUEwRSxFQUFFLFlBQVksRUFBRTtBQUMxRiwyRUFBMkUsRUFBRSxZQUFZLEVBQUU7QUFDM0YseUVBQXlFLEVBQUU7QUFDM0UsaUZBQWlGLEVBQUU7QUFDbkYsa0ZBQWtGLEdBQUcsY0FBYyxFQUFFOztBQUVyRztBQUNBLG1FQUFtRSxHQUFHLGlCQUFpQixFQUFFO0FBQ3pGLGtFQUFrRSxHQUFHLGlCQUFpQixFQUFFO0FBQ3hGLDRFQUE0RSxFQUFFLEdBQUcsRUFBRTs7QUFFbkY7QUFDQSx1REFBdUQsRUFBRSw4QkFBOEIsRUFBRTtBQUN6Rix1REFBdUQsRUFBRTtBQUN6RCx1REFBdUQsRUFBRTtBQUN6RCx1REFBdUQsRUFBRSxXQUFXLEVBQUU7QUFDdEUsdURBQXVELEVBQUUscUJBQXFCLEVBQUU7QUFDaEYsdURBQXVELEVBQUUsa0NBQWtDLEVBQUU7QUFDN0YsdUVBQXVFLEVBQUUsb0JBQW9CLEVBQUU7QUFDL0YsMEZBQTBGLEVBQUU7QUFDNUYsOENBQThDLEdBQUc7O0FBRWpEO0FBQ0Esa0dBQWtHLEVBQUU7QUFDcEcsK0VBQStFLEVBQUU7QUFDakYsOEZBQThGLEVBQUU7QUFDaEc7QUFDQSx1RUFBdUUsRUFBRTtBQUN6RSw4Q0FBOEMsR0FBRywyQ0FBMkMsR0FBRztBQUMvRjtBQUNBLDRGQUE0RixFQUFFOztBQUU5RiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFx6LXNjaGVtYVxcc3JjXFxFcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSU5WQUxJRF9UWVBFOiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdHlwZSB7MH0gYnV0IGZvdW5kIHR5cGUgezF9XCIsXG4gICAgSU5WQUxJRF9GT1JNQVQ6ICAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0IGRpZG4ndCBwYXNzIHZhbGlkYXRpb24gZm9yIGZvcm1hdCB7MH06IHsxfVwiLFxuICAgIEVOVU1fTUlTTUFUQ0g6ICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vIGVudW0gbWF0Y2ggZm9yOiB7MH1cIixcbiAgICBFTlVNX0NBU0VfTUlTTUFUQ0g6ICAgICAgICAgICAgICAgICAgICAgXCJFbnVtIGRvZXMgbm90IG1hdGNoIGNhc2UgZm9yOiB7MH1cIixcbiAgICBBTllfT0ZfTUlTU0lORzogICAgICAgICAgICAgICAgICAgICAgICAgXCJEYXRhIGRvZXMgbm90IG1hdGNoIGFueSBzY2hlbWFzIGZyb20gJ2FueU9mJ1wiLFxuICAgIE9ORV9PRl9NSVNTSU5HOiAgICAgICAgICAgICAgICAgICAgICAgICBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSAnb25lT2YnXCIsXG4gICAgT05FX09GX01VTFRJUExFOiAgICAgICAgICAgICAgICAgICAgICAgIFwiRGF0YSBpcyB2YWxpZCBhZ2FpbnN0IG1vcmUgdGhhbiBvbmUgc2NoZW1hIGZyb20gJ29uZU9mJ1wiLFxuICAgIE5PVF9QQVNTRUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRhdGEgbWF0Y2hlcyBzY2hlbWEgZnJvbSAnbm90J1wiLFxuXG4gICAgLy8gQXJyYXkgZXJyb3JzXG4gICAgQVJSQVlfTEVOR1RIX1NIT1JUOiAgICAgICAgICAgICAgICAgICAgIFwiQXJyYXkgaXMgdG9vIHNob3J0ICh7MH0pLCBtaW5pbXVtIHsxfVwiLFxuICAgIEFSUkFZX0xFTkdUSF9MT05HOiAgICAgICAgICAgICAgICAgICAgICBcIkFycmF5IGlzIHRvbyBsb25nICh7MH0pLCBtYXhpbXVtIHsxfVwiLFxuICAgIEFSUkFZX1VOSVFVRTogICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFycmF5IGl0ZW1zIGFyZSBub3QgdW5pcXVlIChpbmRleGVzIHswfSBhbmQgezF9KVwiLFxuICAgIEFSUkFZX0FERElUSU9OQUxfSVRFTVM6ICAgICAgICAgICAgICAgICBcIkFkZGl0aW9uYWwgaXRlbXMgbm90IGFsbG93ZWRcIixcblxuICAgIC8vIE51bWVyaWMgZXJyb3JzXG4gICAgTVVMVElQTEVfT0Y6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVmFsdWUgezB9IGlzIG5vdCBhIG11bHRpcGxlIG9mIHsxfVwiLFxuICAgIE1JTklNVU06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlZhbHVlIHswfSBpcyBsZXNzIHRoYW4gbWluaW11bSB7MX1cIixcbiAgICBNSU5JTVVNX0VYQ0xVU0lWRTogICAgICAgICAgICAgICAgICAgICAgXCJWYWx1ZSB7MH0gaXMgZXF1YWwgb3IgbGVzcyB0aGFuIGV4Y2x1c2l2ZSBtaW5pbXVtIHsxfVwiLFxuICAgIE1BWElNVU06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlZhbHVlIHswfSBpcyBncmVhdGVyIHRoYW4gbWF4aW11bSB7MX1cIixcbiAgICBNQVhJTVVNX0VYQ0xVU0lWRTogICAgICAgICAgICAgICAgICAgICAgXCJWYWx1ZSB7MH0gaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIGV4Y2x1c2l2ZSBtYXhpbXVtIHsxfVwiLFxuXG4gICAgLy8gT2JqZWN0IGVycm9yc1xuICAgIE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06ICAgICAgICAgICAgICBcIlRvbyBmZXcgcHJvcGVydGllcyBkZWZpbmVkICh7MH0pLCBtaW5pbXVtIHsxfVwiLFxuICAgIE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06ICAgICAgICAgICAgICBcIlRvbyBtYW55IHByb3BlcnRpZXMgZGVmaW5lZCAoezB9KSwgbWF4aW11bSB7MX1cIixcbiAgICBPQkpFQ1RfTUlTU0lOR19SRVFVSVJFRF9QUk9QRVJUWTogICAgICAgXCJNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5OiB7MH1cIixcbiAgICBPQkpFQ1RfQURESVRJT05BTF9QUk9QRVJUSUVTOiAgICAgICAgICAgXCJBZGRpdGlvbmFsIHByb3BlcnRpZXMgbm90IGFsbG93ZWQ6IHswfVwiLFxuICAgIE9CSkVDVF9ERVBFTkRFTkNZX0tFWTogICAgICAgICAgICAgICAgICBcIkRlcGVuZGVuY3kgZmFpbGVkIC0ga2V5IG11c3QgZXhpc3Q6IHswfSAoZHVlIHRvIGtleTogezF9KVwiLFxuXG4gICAgLy8gU3RyaW5nIGVycm9yc1xuICAgIE1JTl9MRU5HVEg6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN0cmluZyBpcyB0b28gc2hvcnQgKHswfSBjaGFycyksIG1pbmltdW0gezF9XCIsXG4gICAgTUFYX0xFTkdUSDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3RyaW5nIGlzIHRvbyBsb25nICh7MH0gY2hhcnMpLCBtYXhpbXVtIHsxfVwiLFxuICAgIFBBVFRFUk46ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN0cmluZyBkb2VzIG5vdCBtYXRjaCBwYXR0ZXJuIHswfTogezF9XCIsXG5cbiAgICAvLyBTY2hlbWEgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICBLRVlXT1JEX1RZUEVfRVhQRUNURUQ6ICAgICAgICAgICAgICAgICAgXCJLZXl3b3JkICd7MH0nIGlzIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgJ3sxfSdcIixcbiAgICBLRVlXT1JEX1VOREVGSU5FRF9TVFJJQ1Q6ICAgICAgICAgICAgICAgXCJLZXl3b3JkICd7MH0nIG11c3QgYmUgZGVmaW5lZCBpbiBzdHJpY3QgbW9kZVwiLFxuICAgIEtFWVdPUkRfVU5FWFBFQ1RFRDogICAgICAgICAgICAgICAgICAgICBcIktleXdvcmQgJ3swfScgaXMgbm90IGV4cGVjdGVkIHRvIGFwcGVhciBpbiB0aGUgc2NoZW1hXCIsXG4gICAgS0VZV09SRF9NVVNUX0JFOiAgICAgICAgICAgICAgICAgICAgICAgIFwiS2V5d29yZCAnezB9JyBtdXN0IGJlIHsxfVwiLFxuICAgIEtFWVdPUkRfREVQRU5ERU5DWTogICAgICAgICAgICAgICAgICAgICBcIktleXdvcmQgJ3swfScgcmVxdWlyZXMga2V5d29yZCAnezF9J1wiLFxuICAgIEtFWVdPUkRfUEFUVEVSTjogICAgICAgICAgICAgICAgICAgICAgICBcIktleXdvcmQgJ3swfScgaXMgbm90IGEgdmFsaWQgUmVnRXhwIHBhdHRlcm46IHsxfVwiLFxuICAgIEtFWVdPUkRfVkFMVUVfVFlQRTogICAgICAgICAgICAgICAgICAgICBcIkVhY2ggZWxlbWVudCBvZiBrZXl3b3JkICd7MH0nIGFycmF5IG11c3QgYmUgYSAnezF9J1wiLFxuICAgIFVOS05PV05fRk9STUFUOiAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIGlzIG5vIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGZvcm1hdCAnezB9J1wiLFxuICAgIENVU1RPTV9NT0RFX0ZPUkNFX1BST1BFUlRJRVM6ICAgICAgICAgICBcInswfSBtdXN0IGRlZmluZSBhdCBsZWFzdCBvbmUgcHJvcGVydHkgaWYgcHJlc2VudFwiLFxuXG4gICAgLy8gUmVtb3RlIGVycm9yc1xuICAgIFJFRl9VTlJFU09MVkVEOiAgICAgICAgICAgICAgICAgICAgICAgICBcIlJlZmVyZW5jZSBoYXMgbm90IGJlZW4gcmVzb2x2ZWQgZHVyaW5nIGNvbXBpbGF0aW9uOiB7MH1cIixcbiAgICBVTlJFU09MVkFCTEVfUkVGRVJFTkNFOiAgICAgICAgICAgICAgICAgXCJSZWZlcmVuY2UgY291bGQgbm90IGJlIHJlc29sdmVkOiB7MH1cIixcbiAgICBTQ0hFTUFfTk9UX1JFQUNIQUJMRTogICAgICAgICAgICAgICAgICAgXCJWYWxpZGF0b3Igd2FzIG5vdCBhYmxlIHRvIHJlYWQgc2NoZW1hIHdpdGggdXJpOiB7MH1cIixcbiAgICBTQ0hFTUFfVFlQRV9FWFBFQ1RFRDogICAgICAgICAgICAgICAgICAgXCJTY2hlbWEgaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSAnb2JqZWN0J1wiLFxuICAgIFNDSEVNQV9OT1RfQU5fT0JKRUNUOiAgICAgICAgICAgICAgICAgICBcIlNjaGVtYSBpcyBub3QgYW4gb2JqZWN0OiB7MH1cIixcbiAgICBBU1lOQ19USU1FT1VUOiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ7MH0gYXN5bmNocm9ub3VzIHRhc2socykgaGF2ZSB0aW1lZCBvdXQgYWZ0ZXIgezF9IG1zXCIsXG4gICAgUEFSRU5UX1NDSEVNQV9WQUxJREFUSU9OX0ZBSUxFRDogICAgICAgIFwiU2NoZW1hIGZhaWxlZCB0byB2YWxpZGF0ZSBhZ2FpbnN0IGl0cyBwYXJlbnQgc2NoZW1hLCBzZWUgaW5uZXIgZXJyb3JzIGZvciBkZXRhaWxzLlwiLFxuICAgIFJFTU9URV9OT1RfVkFMSUQ6ICAgICAgICAgICAgICAgICAgICAgICBcIlJlbW90ZSByZWZlcmVuY2UgZGlkbid0IGNvbXBpbGUgc3VjY2Vzc2Z1bGx5OiB7MH1cIlxuXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/Errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/FormatValidators.js":
/*!*******************************************************!*\
  !*** ./node_modules/z-schema/src/FormatValidators.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*jshint maxlen: false*/\n\nvar validator = __webpack_require__(/*! validator */ \"(rsc)/./node_modules/validator/index.js\");\n\nvar FormatValidators = {\n    \"date\": function (date) {\n        if (typeof date !== \"string\") {\n            return true;\n        }\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        var matches = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(date);\n        if (matches === null) {\n            return false;\n        }\n        // var year = matches[1];\n        // var month = matches[2];\n        // var day = matches[3];\n        if (matches[2] < \"01\" || matches[2] > \"12\" || matches[3] < \"01\" || matches[3] > \"31\") {\n            return false;\n        }\n        return true;\n    },\n    \"date-time\": function (dateTime) {\n        if (typeof dateTime !== \"string\") {\n            return true;\n        }\n        // date-time from http://tools.ietf.org/html/rfc3339#section-5.6\n        var s = dateTime.toLowerCase().split(\"t\");\n        if (!FormatValidators.date(s[0])) {\n            return false;\n        }\n        var matches = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(s[1]);\n        if (matches === null) {\n            return false;\n        }\n        // var hour = matches[1];\n        // var minute = matches[2];\n        // var second = matches[3];\n        // var fraction = matches[4];\n        // var timezone = matches[5];\n        if (matches[1] > \"23\" || matches[2] > \"59\" || matches[3] > \"59\") {\n            return false;\n        }\n        return true;\n    },\n    \"email\": function (email) {\n        if (typeof email !== \"string\") {\n            return true;\n        }\n        return validator.isEmail(email, { \"require_tld\": true });\n    },\n    \"hostname\": function (hostname) {\n        if (typeof hostname !== \"string\") {\n            return true;\n        }\n        /*\n            http://json-schema.org/latest/json-schema-validation.html#anchor114\n            A string instance is valid against this attribute if it is a valid\n            representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].\n\n            http://tools.ietf.org/html/rfc1034#section-3.5\n\n            <digit> ::= any one of the ten digits 0 through 9\n            var digit = /[0-9]/;\n\n            <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case\n            var letter = /[a-zA-Z]/;\n\n            <let-dig> ::= <letter> | <digit>\n            var letDig = /[0-9a-zA-Z]/;\n\n            <let-dig-hyp> ::= <let-dig> | \"-\"\n            var letDigHyp = /[-0-9a-zA-Z]/;\n\n            <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n            var ldhStr = /[-0-9a-zA-Z]+/;\n\n            <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]\n            var label = /[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?/;\n\n            <subdomain> ::= <label> | <subdomain> \".\" <label>\n            var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;\n\n            <domain> ::= <subdomain> | \" \"\n            var domain = null;\n        */\n        var valid = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(hostname);\n        if (valid) {\n            // the sum of all label octets and label lengths is limited to 255.\n            if (hostname.length > 255) { return false; }\n            // Each node has a label, which is zero to 63 octets in length\n            var labels = hostname.split(\".\");\n            for (var i = 0; i < labels.length; i++) { if (labels[i].length > 63) { return false; } }\n        }\n        return valid;\n    },\n    \"host-name\": function (hostname) {\n        return FormatValidators.hostname.call(this, hostname);\n    },\n    \"ipv4\": function (ipv4) {\n        if (typeof ipv4 !== \"string\") { return true; }\n        return validator.isIP(ipv4, 4);\n    },\n    \"ipv6\": function (ipv6) {\n        if (typeof ipv6 !== \"string\") { return true; }\n        return validator.isIP(ipv6, 6);\n    },\n    \"regex\": function (str) {\n        try {\n            RegExp(str);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    },\n    \"uri\": function (uri) {\n        if (this.options.strictUris) {\n            return FormatValidators[\"strict-uri\"].apply(this, arguments);\n        }\n        // https://github.com/zaggino/z-schema/issues/18\n        // RegExp from http://tools.ietf.org/html/rfc3986#appendix-B\n        return typeof uri !== \"string\" || RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\").test(uri);\n    },\n    \"strict-uri\": function (uri) {\n        return typeof uri !== \"string\" || validator.isURL(uri);\n    }\n};\n\nmodule.exports = FormatValidators;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL0Zvcm1hdFZhbGlkYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVc7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSx5QkFBeUIsRUFBRSxPQUFPLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQixPQUFPLDZCQUE2QjtBQUNuRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFx6LXNjaGVtYVxcc3JjXFxGb3JtYXRWYWxpZGF0b3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG1heGxlbjogZmFsc2UqL1xuXG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZShcInZhbGlkYXRvclwiKTtcblxudmFyIEZvcm1hdFZhbGlkYXRvcnMgPSB7XG4gICAgXCJkYXRlXCI6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICB2YXIgbWF0Y2hlcyA9IC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSkkLy5leGVjKGRhdGUpO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciB5ZWFyID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgLy8gdmFyIG1vbnRoID0gbWF0Y2hlc1syXTtcbiAgICAgICAgLy8gdmFyIGRheSA9IG1hdGNoZXNbM107XG4gICAgICAgIGlmIChtYXRjaGVzWzJdIDwgXCIwMVwiIHx8IG1hdGNoZXNbMl0gPiBcIjEyXCIgfHwgbWF0Y2hlc1szXSA8IFwiMDFcIiB8fCBtYXRjaGVzWzNdID4gXCIzMVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBcImRhdGUtdGltZVwiOiBmdW5jdGlvbiAoZGF0ZVRpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlVGltZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGF0ZS10aW1lIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICB2YXIgcyA9IGRhdGVUaW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJ0XCIpO1xuICAgICAgICBpZiAoIUZvcm1hdFZhbGlkYXRvcnMuZGF0ZShzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVzID0gL14oWzAtOV17Mn0pOihbMC05XXsyfSk6KFswLTldezJ9KSguWzAtOV0rKT8oenwoWystXVswLTldezJ9OlswLTldezJ9KSkkLy5leGVjKHNbMV0pO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciBob3VyID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgLy8gdmFyIG1pbnV0ZSA9IG1hdGNoZXNbMl07XG4gICAgICAgIC8vIHZhciBzZWNvbmQgPSBtYXRjaGVzWzNdO1xuICAgICAgICAvLyB2YXIgZnJhY3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAvLyB2YXIgdGltZXpvbmUgPSBtYXRjaGVzWzVdO1xuICAgICAgICBpZiAobWF0Y2hlc1sxXSA+IFwiMjNcIiB8fCBtYXRjaGVzWzJdID4gXCI1OVwiIHx8IG1hdGNoZXNbM10gPiBcIjU5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFwiZW1haWxcIjogZnVuY3Rpb24gKGVtYWlsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3IuaXNFbWFpbChlbWFpbCwgeyBcInJlcXVpcmVfdGxkXCI6IHRydWUgfSk7XG4gICAgfSxcbiAgICBcImhvc3RuYW1lXCI6IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGhvc3RuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgICAgaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI2FuY2hvcjExNFxuICAgICAgICAgICAgQSBzdHJpbmcgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCB0aGlzIGF0dHJpYnV0ZSBpZiBpdCBpcyBhIHZhbGlkXG4gICAgICAgICAgICByZXByZXNlbnRhdGlvbiBmb3IgYW4gSW50ZXJuZXQgaG9zdCBuYW1lLCBhcyBkZWZpbmVkIGJ5IFJGQyAxMDM0LCBzZWN0aW9uIDMuMSBbUkZDMTAzNF0uXG5cbiAgICAgICAgICAgIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzQjc2VjdGlvbi0zLjVcblxuICAgICAgICAgICAgPGRpZ2l0PiA6Oj0gYW55IG9uZSBvZiB0aGUgdGVuIGRpZ2l0cyAwIHRocm91Z2ggOVxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gL1swLTldLztcblxuICAgICAgICAgICAgPGxldHRlcj4gOjo9IGFueSBvbmUgb2YgdGhlIDUyIGFscGhhYmV0aWMgY2hhcmFjdGVycyBBIHRocm91Z2ggWiBpbiB1cHBlciBjYXNlIGFuZCBhIHRocm91Z2ggeiBpbiBsb3dlciBjYXNlXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gL1thLXpBLVpdLztcblxuICAgICAgICAgICAgPGxldC1kaWc+IDo6PSA8bGV0dGVyPiB8IDxkaWdpdD5cbiAgICAgICAgICAgIHZhciBsZXREaWcgPSAvWzAtOWEtekEtWl0vO1xuXG4gICAgICAgICAgICA8bGV0LWRpZy1oeXA+IDo6PSA8bGV0LWRpZz4gfCBcIi1cIlxuICAgICAgICAgICAgdmFyIGxldERpZ0h5cCA9IC9bLTAtOWEtekEtWl0vO1xuXG4gICAgICAgICAgICA8bGRoLXN0cj4gOjo9IDxsZXQtZGlnLWh5cD4gfCA8bGV0LWRpZy1oeXA+IDxsZGgtc3RyPlxuICAgICAgICAgICAgdmFyIGxkaFN0ciA9IC9bLTAtOWEtekEtWl0rLztcblxuICAgICAgICAgICAgPGxhYmVsPiA6Oj0gPGxldHRlcj4gWyBbIDxsZGgtc3RyPiBdIDxsZXQtZGlnPiBdXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSAvW2EtekEtWl0oKFstMC05YS16QS1aXSspP1swLTlhLXpBLVpdKT8vO1xuXG4gICAgICAgICAgICA8c3ViZG9tYWluPiA6Oj0gPGxhYmVsPiB8IDxzdWJkb21haW4+IFwiLlwiIDxsYWJlbD5cbiAgICAgICAgICAgIHZhciBzdWJkb21haW4gPSAvXlthLXpBLVpdKChbLTAtOWEtekEtWl0rKT9bMC05YS16QS1aXSk/KFxcLlthLXpBLVpdKChbLTAtOWEtekEtWl0rKT9bMC05YS16QS1aXSk/KSokLztcblxuICAgICAgICAgICAgPGRvbWFpbj4gOjo9IDxzdWJkb21haW4+IHwgXCIgXCJcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBudWxsO1xuICAgICAgICAqL1xuICAgICAgICB2YXIgdmFsaWQgPSAvXlthLXpBLVpdKChbLTAtOWEtekEtWl0rKT9bMC05YS16QS1aXSk/KFxcLlthLXpBLVpdKChbLTAtOWEtekEtWl0rKT9bMC05YS16QS1aXSk/KSokLy50ZXN0KGhvc3RuYW1lKTtcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3VtIG9mIGFsbCBsYWJlbCBvY3RldHMgYW5kIGxhYmVsIGxlbmd0aHMgaXMgbGltaXRlZCB0byAyNTUuXG4gICAgICAgICAgICBpZiAoaG9zdG5hbWUubGVuZ3RoID4gMjU1KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgLy8gRWFjaCBub2RlIGhhcyBhIGxhYmVsLCB3aGljaCBpcyB6ZXJvIHRvIDYzIG9jdGV0cyBpbiBsZW5ndGhcbiAgICAgICAgICAgIHZhciBsYWJlbHMgPSBob3N0bmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykgeyBpZiAobGFiZWxzW2ldLmxlbmd0aCA+IDYzKSB7IHJldHVybiBmYWxzZTsgfSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0sXG4gICAgXCJob3N0LW5hbWVcIjogZnVuY3Rpb24gKGhvc3RuYW1lKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXRWYWxpZGF0b3JzLmhvc3RuYW1lLmNhbGwodGhpcywgaG9zdG5hbWUpO1xuICAgIH0sXG4gICAgXCJpcHY0XCI6IGZ1bmN0aW9uIChpcHY0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXB2NCAhPT0gXCJzdHJpbmdcIikgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdG9yLmlzSVAoaXB2NCwgNCk7XG4gICAgfSxcbiAgICBcImlwdjZcIjogZnVuY3Rpb24gKGlwdjYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpcHY2ICE9PSBcInN0cmluZ1wiKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3IuaXNJUChpcHY2LCA2KTtcbiAgICB9LFxuICAgIFwicmVnZXhcIjogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVnRXhwKHN0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcInVyaVwiOiBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0VXJpcykge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdFZhbGlkYXRvcnNbXCJzdHJpY3QtdXJpXCJdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3phZ2dpbm8vei1zY2hlbWEvaXNzdWVzLzE4XG4gICAgICAgIC8vIFJlZ0V4cCBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQlxuICAgICAgICByZXR1cm4gdHlwZW9mIHVyaSAhPT0gXCJzdHJpbmdcIiB8fCBSZWdFeHAoXCJeKChbXjovPyNdKyk6KT8oLy8oW14vPyNdKikpPyhbXj8jXSopKFxcXFw/KFteI10qKSk/KCMoLiopKT9cIikudGVzdCh1cmkpO1xuICAgIH0sXG4gICAgXCJzdHJpY3QtdXJpXCI6IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1cmkgIT09IFwic3RyaW5nXCIgfHwgdmFsaWRhdG9yLmlzVVJMKHVyaSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtYXRWYWxpZGF0b3JzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/FormatValidators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/JsonValidation.js":
/*!*****************************************************!*\
  !*** ./node_modules/z-schema/src/JsonValidation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FormatValidators = __webpack_require__(/*! ./FormatValidators */ \"(rsc)/./node_modules/z-schema/src/FormatValidators.js\"),\n    Report           = __webpack_require__(/*! ./Report */ \"(rsc)/./node_modules/z-schema/src/Report.js\"),\n    Utils            = __webpack_require__(/*! ./Utils */ \"(rsc)/./node_modules/z-schema/src/Utils.js\");\n\nvar shouldSkipValidate = function (options, errors) {\n    return options &&\n        Array.isArray(options.includeErrors) &&\n        options.includeErrors.length > 0 &&\n        !errors.some(function (err) { return options.includeErrors.includes(err);});\n};\n\nvar JsonValidators = {\n    multipleOf: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2\n        if (shouldSkipValidate(this.validateOptions, [\"MULTIPLE_OF\"])) {\n            return;\n        }\n        if (typeof json !== \"number\") {\n            return;\n        }\n\n        var stringMultipleOf = String(schema.multipleOf);\n        var scale = Math.pow(10, stringMultipleOf.length - stringMultipleOf.indexOf(\".\") - 1);\n        if (Utils.whatIs((json * scale) / (schema.multipleOf * scale)) !== \"integer\") {\n            report.addError(\"MULTIPLE_OF\", [json, schema.multipleOf], null, schema);\n        }\n    },\n    maximum: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2\n        if (shouldSkipValidate(this.validateOptions, [\"MAXIMUM\", \"MAXIMUM_EXCLUSIVE\"])) {\n            return;\n        }\n        if (typeof json !== \"number\") {\n            return;\n        }\n        if (schema.exclusiveMaximum !== true) {\n            if (json > schema.maximum) {\n                report.addError(\"MAXIMUM\", [json, schema.maximum], null, schema);\n            }\n        } else {\n            if (json >= schema.maximum) {\n                report.addError(\"MAXIMUM_EXCLUSIVE\", [json, schema.maximum], null, schema);\n            }\n        }\n    },\n    exclusiveMaximum: function () {\n        // covered in maximum\n    },\n    minimum: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2\n        if (shouldSkipValidate(this.validateOptions, [\"MINIMUM\", \"MINIMUM_EXCLUSIVE\"])) {\n            return;\n        }\n        if (typeof json !== \"number\") {\n            return;\n        }\n        if (schema.exclusiveMinimum !== true) {\n            if (json < schema.minimum) {\n                report.addError(\"MINIMUM\", [json, schema.minimum], null, schema);\n            }\n        } else {\n            if (json <= schema.minimum) {\n                report.addError(\"MINIMUM_EXCLUSIVE\", [json, schema.minimum], null, schema);\n            }\n        }\n    },\n    exclusiveMinimum: function () {\n        // covered in minimum\n    },\n    maxLength: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2\n        if (shouldSkipValidate(this.validateOptions, [\"MAX_LENGTH\"])) {\n            return;\n        }\n        if (typeof json !== \"string\") {\n            return;\n        }\n        if (Utils.ucs2decode(json).length > schema.maxLength) {\n            report.addError(\"MAX_LENGTH\", [json.length, schema.maxLength], null, schema);\n        }\n    },\n    minLength: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2\n        if (shouldSkipValidate(this.validateOptions, [\"MIN_LENGTH\"])) {\n            return;\n        }\n        if (typeof json !== \"string\") {\n            return;\n        }\n        if (Utils.ucs2decode(json).length < schema.minLength) {\n            report.addError(\"MIN_LENGTH\", [json.length, schema.minLength], null, schema);\n        }\n    },\n    pattern: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2\n        if (shouldSkipValidate(this.validateOptions, [\"PATTERN\"])) {\n            return;\n        }\n        if (typeof json !== \"string\") {\n            return;\n        }\n        if (RegExp(schema.pattern).test(json) === false) {\n            report.addError(\"PATTERN\", [schema.pattern, json], null, schema);\n        }\n    },\n    additionalItems: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2\n        if (shouldSkipValidate(this.validateOptions, [\"ARRAY_ADDITIONAL_ITEMS\"])) {\n            return;\n        }\n        if (!Array.isArray(json)) {\n            return;\n        }\n        // if the value of \"additionalItems\" is boolean value false and the value of \"items\" is an array,\n        // the json is valid if its size is less than, or equal to, the size of \"items\".\n        if (schema.additionalItems === false && Array.isArray(schema.items)) {\n            if (json.length > schema.items.length) {\n                report.addError(\"ARRAY_ADDITIONAL_ITEMS\", null, null, schema);\n            }\n        }\n    },\n    items: function () { /*report, schema, json*/\n        // covered in additionalItems\n    },\n    maxItems: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2\n        if (shouldSkipValidate(this.validateOptions, [\"ARRAY_LENGTH_LONG\"])) {\n            return;\n        }\n        if (!Array.isArray(json)) {\n            return;\n        }\n        if (json.length > schema.maxItems) {\n            report.addError(\"ARRAY_LENGTH_LONG\", [json.length, schema.maxItems], null, schema);\n        }\n    },\n    minItems: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2\n        if (shouldSkipValidate(this.validateOptions, [\"ARRAY_LENGTH_SHORT\"])) {\n            return;\n        }\n        if (!Array.isArray(json)) {\n            return;\n        }\n        if (json.length < schema.minItems) {\n            report.addError(\"ARRAY_LENGTH_SHORT\", [json.length, schema.minItems], null, schema);\n        }\n    },\n    uniqueItems: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2\n        if (shouldSkipValidate(this.validateOptions, [\"ARRAY_UNIQUE\"])) {\n            return;\n        }\n        if (!Array.isArray(json)) {\n            return;\n        }\n        if (schema.uniqueItems === true) {\n            var matches = [];\n            if (Utils.isUniqueArray(json, matches) === false) {\n                report.addError(\"ARRAY_UNIQUE\", matches, null, schema);\n            }\n        }\n    },\n    maxProperties: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2\n        if (shouldSkipValidate(this.validateOptions, [\"OBJECT_PROPERTIES_MAXIMUM\"])) {\n            return;\n        }\n        if (Utils.whatIs(json) !== \"object\") {\n            return;\n        }\n        var keysCount = Object.keys(json).length;\n        if (keysCount > schema.maxProperties) {\n            report.addError(\"OBJECT_PROPERTIES_MAXIMUM\", [keysCount, schema.maxProperties], null, schema);\n        }\n    },\n    minProperties: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2\n        if (shouldSkipValidate(this.validateOptions, [\"OBJECT_PROPERTIES_MINIMUM\"])) {\n            return;\n        }\n        if (Utils.whatIs(json) !== \"object\") {\n            return;\n        }\n        var keysCount = Object.keys(json).length;\n        if (keysCount < schema.minProperties) {\n            report.addError(\"OBJECT_PROPERTIES_MINIMUM\", [keysCount, schema.minProperties], null, schema);\n        }\n    },\n    required: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2\n        if (shouldSkipValidate(this.validateOptions, [\"OBJECT_MISSING_REQUIRED_PROPERTY\"])) {\n            return;\n        }\n        if (Utils.whatIs(json) !== \"object\") {\n            return;\n        }\n        var idx = schema.required.length;\n        while (idx--) {\n            var requiredPropertyName = schema.required[idx];\n            if (json[requiredPropertyName] === undefined) {\n                report.addError(\"OBJECT_MISSING_REQUIRED_PROPERTY\", [requiredPropertyName], null, schema);\n            }\n        }\n    },\n    additionalProperties: function (report, schema, json) {\n        // covered in properties and patternProperties\n        if (schema.properties === undefined && schema.patternProperties === undefined) {\n            return JsonValidators.properties.call(this, report, schema, json);\n        }\n    },\n    patternProperties: function (report, schema, json) {\n        // covered in properties\n        if (schema.properties === undefined) {\n            return JsonValidators.properties.call(this, report, schema, json);\n        }\n    },\n    properties: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2\n        if (shouldSkipValidate(this.validateOptions, [\"OBJECT_ADDITIONAL_PROPERTIES\"])) {\n            return;\n        }\n        if (Utils.whatIs(json) !== \"object\") {\n            return;\n        }\n        var properties = schema.properties !== undefined ? schema.properties : {};\n        var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};\n        if (schema.additionalProperties === false) {\n            // The property set of the json to validate.\n            var s = Object.keys(json);\n            // The property set from \"properties\".\n            var p = Object.keys(properties);\n            // The property set from \"patternProperties\".\n            var pp = Object.keys(patternProperties);\n            // remove from \"s\" all elements of \"p\", if any;\n            s = Utils.difference(s, p);\n            // for each regex in \"pp\", remove all elements of \"s\" which this regex matches.\n            var idx = pp.length;\n            while (idx--) {\n                var regExp = RegExp(pp[idx]),\n                    idx2 = s.length;\n                while (idx2--) {\n                    if (regExp.test(s[idx2]) === true) {\n                        s.splice(idx2, 1);\n                    }\n                }\n            }\n            // Validation of the json succeeds if, after these two steps, set \"s\" is empty.\n            if (s.length > 0) {\n                // assumeAdditional can be an array of allowed properties\n                var idx3 = this.options.assumeAdditional.length;\n                if (idx3) {\n                    while (idx3--) {\n                        var io = s.indexOf(this.options.assumeAdditional[idx3]);\n                        if (io !== -1) {\n                            s.splice(io, 1);\n                        }\n                    }\n                }\n                var idx4 = s.length;\n                if (idx4) {\n                    while (idx4--) {\n                        report.addError(\"OBJECT_ADDITIONAL_PROPERTIES\", [s[idx4]], null, schema);\n                    }\n                }\n            }\n        }\n    },\n    dependencies: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2\n        if (shouldSkipValidate(this.validateOptions, [\"OBJECT_DEPENDENCY_KEY\"])) {\n            return;\n        }\n        if (Utils.whatIs(json) !== \"object\") {\n            return;\n        }\n\n        var keys = Object.keys(schema.dependencies),\n            idx = keys.length;\n\n        while (idx--) {\n            // iterate all dependencies\n            var dependencyName = keys[idx];\n            if (json[dependencyName]) {\n                var dependencyDefinition = schema.dependencies[dependencyName];\n                if (Utils.whatIs(dependencyDefinition) === \"object\") {\n                    // if dependency is a schema, validate against this schema\n                    exports.validate.call(this, report, dependencyDefinition, json);\n                } else { // Array\n                    // if dependency is an array, object needs to have all properties in this array\n                    var idx2 = dependencyDefinition.length;\n                    while (idx2--) {\n                        var requiredPropertyName = dependencyDefinition[idx2];\n                        if (json[requiredPropertyName] === undefined) {\n                            report.addError(\"OBJECT_DEPENDENCY_KEY\", [requiredPropertyName, dependencyName], null, schema);\n                        }\n                    }\n                }\n            }\n        }\n    },\n    enum: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2\n        if (shouldSkipValidate(this.validateOptions, [\"ENUM_CASE_MISMATCH\", \"ENUM_MISMATCH\"])) {\n            return;\n        }\n        var match = false,\n            caseInsensitiveMatch = false,\n            idx = schema.enum.length;\n        while (idx--) {\n            if (Utils.areEqual(json, schema.enum[idx])) {\n                match = true;\n                break;\n            } else if (Utils.areEqual(json, schema.enum[idx]), { caseInsensitiveComparison: true }) {\n                caseInsensitiveMatch = true;\n            }\n        }\n\n        if (match === false) {\n            var error = caseInsensitiveMatch && this.options.enumCaseInsensitiveComparison ? \"ENUM_CASE_MISMATCH\" : \"ENUM_MISMATCH\";\n            report.addError(error, [json], null, schema);\n        }\n    },\n    type: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2\n        if (shouldSkipValidate(this.validateOptions, [\"INVALID_TYPE\"])) {\n            return;\n        }\n        var jsonType = Utils.whatIs(json);\n        if (typeof schema.type === \"string\") {\n            if (jsonType !== schema.type && (jsonType !== \"integer\" || schema.type !== \"number\")) {\n                report.addError(\"INVALID_TYPE\", [schema.type, jsonType], null, schema);\n            }\n        } else {\n            if (schema.type.indexOf(jsonType) === -1 && (jsonType !== \"integer\" || schema.type.indexOf(\"number\") === -1)) {\n                report.addError(\"INVALID_TYPE\", [schema.type, jsonType], null, schema);\n            }\n        }\n    },\n    allOf: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2\n        var idx = schema.allOf.length;\n        while (idx--) {\n            var validateResult = exports.validate.call(this, report, schema.allOf[idx], json);\n            if (this.options.breakOnFirstError && validateResult === false) {\n                break;\n            }\n        }\n    },\n    anyOf: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2\n        var subReports = [],\n            passed = false,\n            idx = schema.anyOf.length;\n\n        while (idx-- && passed === false) {\n            var subReport = new Report(report);\n            subReports.push(subReport);\n            passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);\n        }\n\n        if (passed === false) {\n            report.addError(\"ANY_OF_MISSING\", undefined, subReports, schema);\n        }\n    },\n    oneOf: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2\n        var passes = 0,\n            subReports = [],\n            idx = schema.oneOf.length;\n\n        while (idx--) {\n            var subReport = new Report(report, { maxErrors: 1 });\n            subReports.push(subReport);\n            if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {\n                passes++;\n            }\n        }\n\n        if (passes === 0) {\n            report.addError(\"ONE_OF_MISSING\", undefined, subReports, schema);\n        } else if (passes > 1) {\n            report.addError(\"ONE_OF_MULTIPLE\", null, null, schema);\n        }\n    },\n    not: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2\n        var subReport = new Report(report);\n        if (exports.validate.call(this, subReport, schema.not, json) === true) {\n            report.addError(\"NOT_PASSED\", null, null, schema);\n        }\n    },\n    definitions: function () { /*report, schema, json*/\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.2\n        // nothing to do here\n    },\n    format: function (report, schema, json) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2\n        var formatValidatorFn = FormatValidators[schema.format];\n        if (typeof formatValidatorFn === \"function\") {\n            if (shouldSkipValidate(this.validateOptions, [\"INVALID_FORMAT\"])) {\n                return;\n            }\n            if (formatValidatorFn.length === 2) {\n                // async - need to clone the path here, because it will change by the time async function reports back\n                var pathBeforeAsync = Utils.clone(report.path);\n                report.addAsyncTask(formatValidatorFn, [json], function (result) {\n                    if (result !== true) {\n                        var backup = report.path;\n                        report.path = pathBeforeAsync;\n                        report.addError(\"INVALID_FORMAT\", [schema.format, json], null, schema);\n                        report.path = backup;\n                    }\n                });\n            } else {\n                // sync\n                if (formatValidatorFn.call(this, json) !== true) {\n                    report.addError(\"INVALID_FORMAT\", [schema.format, json], null, schema);\n                }\n            }\n        } else if (this.options.ignoreUnknownFormats !== true) {\n            report.addError(\"UNKNOWN_FORMAT\", [schema.format], null, schema);\n        }\n    }\n};\n\nvar recurseArray = function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2\n\n    var idx = json.length;\n\n    // If \"items\" is an array, this situation, the schema depends on the index:\n    // if the index is less than, or equal to, the size of \"items\",\n    // the child instance must be valid against the corresponding schema in the \"items\" array;\n    // otherwise, it must be valid against the schema defined by \"additionalItems\".\n    if (Array.isArray(schema.items)) {\n\n        while (idx--) {\n            // equal to doesn't make sense here\n            if (idx < schema.items.length) {\n                report.path.push(idx);\n                exports.validate.call(this, report, schema.items[idx], json[idx]);\n                report.path.pop();\n            } else {\n                // might be boolean, so check that it's an object\n                if (typeof schema.additionalItems === \"object\") {\n                    report.path.push(idx);\n                    exports.validate.call(this, report, schema.additionalItems, json[idx]);\n                    report.path.pop();\n                }\n            }\n        }\n\n    } else if (typeof schema.items === \"object\") {\n\n        // If items is a schema, then the child instance must be valid against this schema,\n        // regardless of its index, and regardless of the value of \"additionalItems\".\n        while (idx--) {\n            report.path.push(idx);\n            exports.validate.call(this, report, schema.items, json[idx]);\n            report.path.pop();\n        }\n\n    }\n};\n\nvar recurseObject = function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3\n\n    // If \"additionalProperties\" is absent, it is considered present with an empty schema as a value.\n    // In addition, boolean value true is considered equivalent to an empty schema.\n    var additionalProperties = schema.additionalProperties;\n    if (additionalProperties === true || additionalProperties === undefined) {\n        additionalProperties = {};\n    }\n\n    // p - The property set from \"properties\".\n    var p = schema.properties ? Object.keys(schema.properties) : [];\n\n    // pp - The property set from \"patternProperties\". Elements of this set will be called regexes for convenience.\n    var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];\n\n    // m - The property name of the child.\n    var keys = Object.keys(json),\n        idx = keys.length;\n\n    while (idx--) {\n        var m = keys[idx],\n            propertyValue = json[m];\n\n        // s - The set of schemas for the child instance.\n        var s = [];\n\n        // 1. If set \"p\" contains value \"m\", then the corresponding schema in \"properties\" is added to \"s\".\n        if (p.indexOf(m) !== -1) {\n            s.push(schema.properties[m]);\n        }\n\n        // 2. For each regex in \"pp\", if it matches \"m\" successfully, the corresponding schema in \"patternProperties\" is added to \"s\".\n        var idx2 = pp.length;\n        while (idx2--) {\n            var regexString = pp[idx2];\n            if (RegExp(regexString).test(m) === true) {\n                s.push(schema.patternProperties[regexString]);\n            }\n        }\n\n        // 3. The schema defined by \"additionalProperties\" is added to \"s\" if and only if, at this stage, \"s\" is empty.\n        if (s.length === 0 && additionalProperties !== false) {\n            s.push(additionalProperties);\n        }\n\n        // we are passing tests even without this assert because this is covered by properties check\n        // if s is empty in this stage, no additionalProperties are allowed\n        // report.expect(s.length !== 0, 'E001', m);\n\n        // Instance property value must pass all schemas from s\n        idx2 = s.length;\n        while (idx2--) {\n            report.path.push(m);\n            exports.validate.call(this, report, s[idx2], propertyValue);\n            report.path.pop();\n        }\n    }\n};\n\nexports.JsonValidators = JsonValidators;\n\n/**\n *\n * @param {Report} report\n * @param {*} schema\n * @param {*} json\n */\nexports.validate = function (report, schema, json) {\n\n    report.commonErrorMessage = \"JSON_OBJECT_VALIDATION_FAILED\";\n\n    // check if schema is an object\n    var to = Utils.whatIs(schema);\n    if (to !== \"object\") {\n        report.addError(\"SCHEMA_NOT_AN_OBJECT\", [to], null, schema);\n        return false;\n    }\n\n    // check if schema is empty, everything is valid against empty schema\n    var keys = Object.keys(schema);\n    if (keys.length === 0) {\n        return true;\n    }\n\n    // this method can be called recursively, so we need to remember our root\n    var isRoot = false;\n    if (!report.rootSchema) {\n        report.rootSchema = schema;\n        isRoot = true;\n    }\n\n    // follow schema.$ref keys\n    if (schema.$ref !== undefined) {\n        // avoid infinite loop with maxRefs\n        var maxRefs = 99;\n        while (schema.$ref && maxRefs > 0) {\n            if (!schema.__$refResolved) {\n                report.addError(\"REF_UNRESOLVED\", [schema.$ref], null, schema);\n                break;\n            } else if (schema.__$refResolved === schema) {\n                break;\n            } else {\n                schema = schema.__$refResolved;\n                keys = Object.keys(schema);\n            }\n            maxRefs--;\n        }\n        if (maxRefs === 0) {\n            throw new Error(\"Circular dependency by $ref references!\");\n        }\n    }\n\n    // type checking first\n    var jsonType = Utils.whatIs(json);\n    if (schema.type) {\n        keys.splice(keys.indexOf(\"type\"), 1);\n        JsonValidators.type.call(this, report, schema, json);\n        if (report.errors.length && this.options.breakOnFirstError) {\n            return false;\n        }\n    }\n\n    // now iterate all the keys in schema and execute validation methods\n    var idx = keys.length;\n    while (idx--) {\n        if (JsonValidators[keys[idx]]) {\n            JsonValidators[keys[idx]].call(this, report, schema, json);\n            if (report.errors.length && this.options.breakOnFirstError) { break; }\n        }\n    }\n\n    if (report.errors.length === 0 || this.options.breakOnFirstError === false) {\n        if (jsonType === \"array\") {\n            recurseArray.call(this, report, schema, json);\n        } else if (jsonType === \"object\") {\n            recurseObject.call(this, report, schema, json);\n        }\n    }\n\n    if (typeof this.options.customValidator === \"function\") {\n        this.options.customValidator.call(this, report, schema, json);\n    }\n\n    // we don't need the root pointer anymore\n    if (isRoot) {\n        report.rootSchema = undefined;\n    }\n\n    // return valid just to be able to break at some code points\n    return report.errors.length === 0;\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL0pzb25WYWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLGlGQUFvQjtBQUNuRCx1QkFBdUIsbUJBQU8sQ0FBQyw2REFBVTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQywyREFBUzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUI7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQW1ELGlDQUFpQztBQUNsRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0EsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEhhcnl1NTQxMlxcRGVza3RvcFxcU2Nob29sXFxjYXBzdG9uZVxccGljc2VsXFxiYWNrZW5kXFxub2RlX21vZHVsZXNcXHotc2NoZW1hXFxzcmNcXEpzb25WYWxpZGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgRm9ybWF0VmFsaWRhdG9ycyA9IHJlcXVpcmUoXCIuL0Zvcm1hdFZhbGlkYXRvcnNcIiksXG4gICAgUmVwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1JlcG9ydFwiKSxcbiAgICBVdGlscyAgICAgICAgICAgID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG5cbnZhciBzaG91bGRTa2lwVmFsaWRhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgZXJyb3JzKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVFcnJvcnMpICYmXG4gICAgICAgIG9wdGlvbnMuaW5jbHVkZUVycm9ycy5sZW5ndGggPiAwICYmXG4gICAgICAgICFlcnJvcnMuc29tZShmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBvcHRpb25zLmluY2x1ZGVFcnJvcnMuaW5jbHVkZXMoZXJyKTt9KTtcbn07XG5cbnZhciBKc29uVmFsaWRhdG9ycyA9IHtcbiAgICBtdWx0aXBsZU9mOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMS4xLjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiTVVMVElQTEVfT0ZcIl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyaW5nTXVsdGlwbGVPZiA9IFN0cmluZyhzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDEwLCBzdHJpbmdNdWx0aXBsZU9mLmxlbmd0aCAtIHN0cmluZ011bHRpcGxlT2YuaW5kZXhPZihcIi5cIikgLSAxKTtcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcygoanNvbiAqIHNjYWxlKSAvIChzY2hlbWEubXVsdGlwbGVPZiAqIHNjYWxlKSkgIT09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJNVUxUSVBMRV9PRlwiLCBbanNvbiwgc2NoZW1hLm11bHRpcGxlT2ZdLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXhpbXVtOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMS4yLjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiTUFYSU1VTVwiLCBcIk1BWElNVU1fRVhDTFVTSVZFXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGpzb24gPiBzY2hlbWEubWF4aW11bSkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIk1BWElNVU1cIiwgW2pzb24sIHNjaGVtYS5tYXhpbXVtXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChqc29uID49IHNjaGVtYS5tYXhpbXVtKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiTUFYSU1VTV9FWENMVVNJVkVcIiwgW2pzb24sIHNjaGVtYS5tYXhpbXVtXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb3ZlcmVkIGluIG1heGltdW1cbiAgICB9LFxuICAgIG1pbmltdW06IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4xLjMuMlxuICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRlKHRoaXMudmFsaWRhdGVPcHRpb25zLCBbXCJNSU5JTVVNXCIsIFwiTUlOSU1VTV9FWENMVVNJVkVcIl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoanNvbiA8IHNjaGVtYS5taW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiTUlOSU1VTVwiLCBbanNvbiwgc2NoZW1hLm1pbmltdW1dLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGpzb24gPD0gc2NoZW1hLm1pbmltdW0pIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJNSU5JTVVNX0VYQ0xVU0lWRVwiLCBbanNvbiwgc2NoZW1hLm1pbmltdW1dLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvdmVyZWQgaW4gbWluaW11bVxuICAgIH0sXG4gICAgbWF4TGVuZ3RoOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMi4xLjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiTUFYX0xFTkdUSFwiXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMudWNzMmRlY29kZShqc29uKS5sZW5ndGggPiBzY2hlbWEubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJNQVhfTEVOR1RIXCIsIFtqc29uLmxlbmd0aCwgc2NoZW1hLm1heExlbmd0aF0sIG51bGwsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pbkxlbmd0aDogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjIuMi4yXG4gICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIk1JTl9MRU5HVEhcIl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLnVjczJkZWNvZGUoanNvbikubGVuZ3RoIDwgc2NoZW1hLm1pbkxlbmd0aCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiTUlOX0xFTkdUSFwiLCBbanNvbi5sZW5ndGgsIHNjaGVtYS5taW5MZW5ndGhdLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwYXR0ZXJuOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMi4zLjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiUEFUVEVSTlwiXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVnRXhwKHNjaGVtYS5wYXR0ZXJuKS50ZXN0KGpzb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiUEFUVEVSTlwiLCBbc2NoZW1hLnBhdHRlcm4sIGpzb25dLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRpdGlvbmFsSXRlbXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4zLjEuMlxuICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRlKHRoaXMudmFsaWRhdGVPcHRpb25zLCBbXCJBUlJBWV9BRERJVElPTkFMX0lURU1TXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBvZiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGJvb2xlYW4gdmFsdWUgZmFsc2UgYW5kIHRoZSB2YWx1ZSBvZiBcIml0ZW1zXCIgaXMgYW4gYXJyYXksXG4gICAgICAgIC8vIHRoZSBqc29uIGlzIHZhbGlkIGlmIGl0cyBzaXplIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSBzaXplIG9mIFwiaXRlbXNcIi5cbiAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IGZhbHNlICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuICAgICAgICAgICAgaWYgKGpzb24ubGVuZ3RoID4gc2NoZW1hLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIkFSUkFZX0FERElUSU9OQUxfSVRFTVNcIiwgbnVsbCwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXRlbXM6IGZ1bmN0aW9uICgpIHsgLypyZXBvcnQsIHNjaGVtYSwganNvbiovXG4gICAgICAgIC8vIGNvdmVyZWQgaW4gYWRkaXRpb25hbEl0ZW1zXG4gICAgfSxcbiAgICBtYXhJdGVtczogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjMuMi4yXG4gICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIkFSUkFZX0xFTkdUSF9MT05HXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLmxlbmd0aCA+IHNjaGVtYS5tYXhJdGVtcykge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiQVJSQVlfTEVOR1RIX0xPTkdcIiwgW2pzb24ubGVuZ3RoLCBzY2hlbWEubWF4SXRlbXNdLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtaW5JdGVtczogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjMuMy4yXG4gICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIkFSUkFZX0xFTkdUSF9TSE9SVFwiXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5sZW5ndGggPCBzY2hlbWEubWluSXRlbXMpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIkFSUkFZX0xFTkdUSF9TSE9SVFwiLCBbanNvbi5sZW5ndGgsIHNjaGVtYS5taW5JdGVtc10sIG51bGwsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVuaXF1ZUl0ZW1zOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMy40LjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiQVJSQVlfVU5JUVVFXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEudW5pcXVlSXRlbXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNVbmlxdWVBcnJheShqc29uLCBtYXRjaGVzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJBUlJBWV9VTklRVUVcIiwgbWF0Y2hlcywgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWF4UHJvcGVydGllczogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjQuMS4yXG4gICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIk9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU1cIl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhqc29uKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzQ291bnQgPSBPYmplY3Qua2V5cyhqc29uKS5sZW5ndGg7XG4gICAgICAgIGlmIChrZXlzQ291bnQgPiBzY2hlbWEubWF4UHJvcGVydGllcykge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiT0JKRUNUX1BST1BFUlRJRVNfTUFYSU1VTVwiLCBba2V5c0NvdW50LCBzY2hlbWEubWF4UHJvcGVydGllc10sIG51bGwsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pblByb3BlcnRpZXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS40LjIuMlxuICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRlKHRoaXMudmFsaWRhdGVPcHRpb25zLCBbXCJPQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy53aGF0SXMoanNvbikgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5c0NvdW50ID0gT2JqZWN0LmtleXMoanNvbikubGVuZ3RoO1xuICAgICAgICBpZiAoa2V5c0NvdW50IDwgc2NoZW1hLm1pblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIk9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU1cIiwgW2tleXNDb3VudCwgc2NoZW1hLm1pblByb3BlcnRpZXNdLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXF1aXJlZDogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjQuMy4yXG4gICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIk9CSkVDVF9NSVNTSU5HX1JFUVVJUkVEX1BST1BFUlRZXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy53aGF0SXMoanNvbikgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gc2NoZW1hLnJlcXVpcmVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWlyZWRQcm9wZXJ0eU5hbWUgPSBzY2hlbWEucmVxdWlyZWRbaWR4XTtcbiAgICAgICAgICAgIGlmIChqc29uW3JlcXVpcmVkUHJvcGVydHlOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiT0JKRUNUX01JU1NJTkdfUkVRVUlSRURfUFJPUEVSVFlcIiwgW3JlcXVpcmVkUHJvcGVydHlOYW1lXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBjb3ZlcmVkIGluIHByb3BlcnRpZXMgYW5kIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gSnNvblZhbGlkYXRvcnMucHJvcGVydGllcy5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hLCBqc29uKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBjb3ZlcmVkIGluIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBKc29uVmFsaWRhdG9ycy5wcm9wZXJ0aWVzLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEsIGpzb24pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNC40LjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFU1wiXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMud2hhdElzKGpzb24pICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkID8gc2NoZW1hLnByb3BlcnRpZXMgOiB7fTtcbiAgICAgICAgdmFyIHBhdHRlcm5Qcm9wZXJ0aWVzID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgPyBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMgOiB7fTtcbiAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcm9wZXJ0eSBzZXQgb2YgdGhlIGpzb24gdG8gdmFsaWRhdGUuXG4gICAgICAgICAgICB2YXIgcyA9IE9iamVjdC5rZXlzKGpzb24pO1xuICAgICAgICAgICAgLy8gVGhlIHByb3BlcnR5IHNldCBmcm9tIFwicHJvcGVydGllc1wiLlxuICAgICAgICAgICAgdmFyIHAgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIC8vIFRoZSBwcm9wZXJ0eSBzZXQgZnJvbSBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIuXG4gICAgICAgICAgICB2YXIgcHAgPSBPYmplY3Qua2V5cyhwYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBcInNcIiBhbGwgZWxlbWVudHMgb2YgXCJwXCIsIGlmIGFueTtcbiAgICAgICAgICAgIHMgPSBVdGlscy5kaWZmZXJlbmNlKHMsIHApO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggcmVnZXggaW4gXCJwcFwiLCByZW1vdmUgYWxsIGVsZW1lbnRzIG9mIFwic1wiIHdoaWNoIHRoaXMgcmVnZXggbWF0Y2hlcy5cbiAgICAgICAgICAgIHZhciBpZHggPSBwcC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwID0gUmVnRXhwKHBwW2lkeF0pLFxuICAgICAgICAgICAgICAgICAgICBpZHgyID0gcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlkeDItLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVnRXhwLnRlc3Qoc1tpZHgyXSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuc3BsaWNlKGlkeDIsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFsaWRhdGlvbiBvZiB0aGUganNvbiBzdWNjZWVkcyBpZiwgYWZ0ZXIgdGhlc2UgdHdvIHN0ZXBzLCBzZXQgXCJzXCIgaXMgZW1wdHkuXG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lQWRkaXRpb25hbCBjYW4gYmUgYW4gYXJyYXkgb2YgYWxsb3dlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgdmFyIGlkeDMgPSB0aGlzLm9wdGlvbnMuYXNzdW1lQWRkaXRpb25hbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGlkeDMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlkeDMtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlvID0gcy5pbmRleE9mKHRoaXMub3B0aW9ucy5hc3N1bWVBZGRpdGlvbmFsW2lkeDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnNwbGljZShpbywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlkeDQgPSBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaWR4NCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaWR4NC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJPQkpFQ1RfQURESVRJT05BTF9QUk9QRVJUSUVTXCIsIFtzW2lkeDRdXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNC41LjJcbiAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0ZSh0aGlzLnZhbGlkYXRlT3B0aW9ucywgW1wiT0JKRUNUX0RFUEVOREVOQ1lfS0VZXCJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy53aGF0SXMoanNvbikgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgICBpZHggPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYWxsIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3lOYW1lID0ga2V5c1tpZHhdO1xuICAgICAgICAgICAgaWYgKGpzb25bZGVwZW5kZW5jeU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3lEZWZpbml0aW9uID0gc2NoZW1hLmRlcGVuZGVuY2llc1tkZXBlbmRlbmN5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhkZXBlbmRlbmN5RGVmaW5pdGlvbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGVwZW5kZW5jeSBpcyBhIHNjaGVtYSwgdmFsaWRhdGUgYWdhaW5zdCB0aGlzIHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlLmNhbGwodGhpcywgcmVwb3J0LCBkZXBlbmRlbmN5RGVmaW5pdGlvbiwganNvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGVwZW5kZW5jeSBpcyBhbiBhcnJheSwgb2JqZWN0IG5lZWRzIHRvIGhhdmUgYWxsIHByb3BlcnRpZXMgaW4gdGhpcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4MiA9IGRlcGVuZGVuY3lEZWZpbml0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlkeDItLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVpcmVkUHJvcGVydHlOYW1lID0gZGVwZW5kZW5jeURlZmluaXRpb25baWR4Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbltyZXF1aXJlZFByb3BlcnR5TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIk9CSkVDVF9ERVBFTkRFTkNZX0tFWVwiLCBbcmVxdWlyZWRQcm9wZXJ0eU5hbWUsIGRlcGVuZGVuY3lOYW1lXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW51bTogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjUuMS4yXG4gICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIkVOVU1fQ0FTRV9NSVNNQVRDSFwiLCBcIkVOVU1fTUlTTUFUQ0hcIl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmVNYXRjaCA9IGZhbHNlLFxuICAgICAgICAgICAgaWR4ID0gc2NoZW1hLmVudW0ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5hcmVFcXVhbChqc29uLCBzY2hlbWEuZW51bVtpZHhdKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuYXJlRXF1YWwoanNvbiwgc2NoZW1hLmVudW1baWR4XSksIHsgY2FzZUluc2Vuc2l0aXZlQ29tcGFyaXNvbjogdHJ1ZSB9KSB7XG4gICAgICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gY2FzZUluc2Vuc2l0aXZlTWF0Y2ggJiYgdGhpcy5vcHRpb25zLmVudW1DYXNlSW5zZW5zaXRpdmVDb21wYXJpc29uID8gXCJFTlVNX0NBU0VfTUlTTUFUQ0hcIiA6IFwiRU5VTV9NSVNNQVRDSFwiO1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKGVycm9yLCBbanNvbl0sIG51bGwsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHR5cGU6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS41LjIuMlxuICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRlKHRoaXMudmFsaWRhdGVPcHRpb25zLCBbXCJJTlZBTElEX1RZUEVcIl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGpzb25UeXBlID0gVXRpbHMud2hhdElzKGpzb24pO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoanNvblR5cGUgIT09IHNjaGVtYS50eXBlICYmIChqc29uVHlwZSAhPT0gXCJpbnRlZ2VyXCIgfHwgc2NoZW1hLnR5cGUgIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiSU5WQUxJRF9UWVBFXCIsIFtzY2hlbWEudHlwZSwganNvblR5cGVdLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlLmluZGV4T2YoanNvblR5cGUpID09PSAtMSAmJiAoanNvblR5cGUgIT09IFwiaW50ZWdlclwiIHx8IHNjaGVtYS50eXBlLmluZGV4T2YoXCJudW1iZXJcIikgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIklOVkFMSURfVFlQRVwiLCBbc2NoZW1hLnR5cGUsIGpzb25UeXBlXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWxsT2Y6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS41LjMuMlxuICAgICAgICB2YXIgaWR4ID0gc2NoZW1hLmFsbE9mLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVSZXN1bHQgPSBleHBvcnRzLnZhbGlkYXRlLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEuYWxsT2ZbaWR4XSwganNvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrT25GaXJzdEVycm9yICYmIHZhbGlkYXRlUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhbnlPZjogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjUuNC4yXG4gICAgICAgIHZhciBzdWJSZXBvcnRzID0gW10sXG4gICAgICAgICAgICBwYXNzZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGlkeCA9IHNjaGVtYS5hbnlPZi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGlkeC0tICYmIHBhc3NlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBzdWJSZXBvcnQgPSBuZXcgUmVwb3J0KHJlcG9ydCk7XG4gICAgICAgICAgICBzdWJSZXBvcnRzLnB1c2goc3ViUmVwb3J0KTtcbiAgICAgICAgICAgIHBhc3NlZCA9IGV4cG9ydHMudmFsaWRhdGUuY2FsbCh0aGlzLCBzdWJSZXBvcnQsIHNjaGVtYS5hbnlPZltpZHhdLCBqc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJBTllfT0ZfTUlTU0lOR1wiLCB1bmRlZmluZWQsIHN1YlJlcG9ydHMsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uZU9mOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNS41LjJcbiAgICAgICAgdmFyIHBhc3NlcyA9IDAsXG4gICAgICAgICAgICBzdWJSZXBvcnRzID0gW10sXG4gICAgICAgICAgICBpZHggPSBzY2hlbWEub25lT2YubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgdmFyIHN1YlJlcG9ydCA9IG5ldyBSZXBvcnQocmVwb3J0LCB7IG1heEVycm9yczogMSB9KTtcbiAgICAgICAgICAgIHN1YlJlcG9ydHMucHVzaChzdWJSZXBvcnQpO1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMudmFsaWRhdGUuY2FsbCh0aGlzLCBzdWJSZXBvcnQsIHNjaGVtYS5vbmVPZltpZHhdLCBqc29uKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHBhc3NlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhc3NlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiT05FX09GX01JU1NJTkdcIiwgdW5kZWZpbmVkLCBzdWJSZXBvcnRzLCBzY2hlbWEpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhc3NlcyA+IDEpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIk9ORV9PRl9NVUxUSVBMRVwiLCBudWxsLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBub3Q6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS41LjYuMlxuICAgICAgICB2YXIgc3ViUmVwb3J0ID0gbmV3IFJlcG9ydChyZXBvcnQpO1xuICAgICAgICBpZiAoZXhwb3J0cy52YWxpZGF0ZS5jYWxsKHRoaXMsIHN1YlJlcG9ydCwgc2NoZW1hLm5vdCwganNvbikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIk5PVF9QQVNTRURcIiwgbnVsbCwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVmaW5pdGlvbnM6IGZ1bmN0aW9uICgpIHsgLypyZXBvcnQsIHNjaGVtYSwganNvbiovXG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjUuNy4yXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgIH0sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjcuMlxuICAgICAgICB2YXIgZm9ybWF0VmFsaWRhdG9yRm4gPSBGb3JtYXRWYWxpZGF0b3JzW3NjaGVtYS5mb3JtYXRdO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdFZhbGlkYXRvckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGUodGhpcy52YWxpZGF0ZU9wdGlvbnMsIFtcIklOVkFMSURfRk9STUFUXCJdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRWYWxpZGF0b3JGbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAtIG5lZWQgdG8gY2xvbmUgdGhlIHBhdGggaGVyZSwgYmVjYXVzZSBpdCB3aWxsIGNoYW5nZSBieSB0aGUgdGltZSBhc3luYyBmdW5jdGlvbiByZXBvcnRzIGJhY2tcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEJlZm9yZUFzeW5jID0gVXRpbHMuY2xvbmUocmVwb3J0LnBhdGgpO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRBc3luY1Rhc2soZm9ybWF0VmFsaWRhdG9yRm4sIFtqc29uXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFja3VwID0gcmVwb3J0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aCA9IHBhdGhCZWZvcmVBc3luYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIklOVkFMSURfRk9STUFUXCIsIFtzY2hlbWEuZm9ybWF0LCBqc29uXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoID0gYmFja3VwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN5bmNcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0VmFsaWRhdG9yRm4uY2FsbCh0aGlzLCBqc29uKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJJTlZBTElEX0ZPUk1BVFwiLCBbc2NoZW1hLmZvcm1hdCwganNvbl0sIG51bGwsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVVbmtub3duRm9ybWF0cyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiVU5LTk9XTl9GT1JNQVRcIiwgW3NjaGVtYS5mb3JtYXRdLCBudWxsLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlY3Vyc2VBcnJheSA9IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi44LjJcblxuICAgIHZhciBpZHggPSBqc29uLmxlbmd0aDtcblxuICAgIC8vIElmIFwiaXRlbXNcIiBpcyBhbiBhcnJheSwgdGhpcyBzaXR1YXRpb24sIHRoZSBzY2hlbWEgZGVwZW5kcyBvbiB0aGUgaW5kZXg6XG4gICAgLy8gaWYgdGhlIGluZGV4IGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSBzaXplIG9mIFwiaXRlbXNcIixcbiAgICAvLyB0aGUgY2hpbGQgaW5zdGFuY2UgbXVzdCBiZSB2YWxpZCBhZ2FpbnN0IHRoZSBjb3JyZXNwb25kaW5nIHNjaGVtYSBpbiB0aGUgXCJpdGVtc1wiIGFycmF5O1xuICAgIC8vIG90aGVyd2lzZSwgaXQgbXVzdCBiZSB2YWxpZCBhZ2FpbnN0IHRoZSBzY2hlbWEgZGVmaW5lZCBieSBcImFkZGl0aW9uYWxJdGVtc1wiLlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcblxuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIC8vIGVxdWFsIHRvIGRvZXNuJ3QgbWFrZSBzZW5zZSBoZXJlXG4gICAgICAgICAgICBpZiAoaWR4IDwgc2NoZW1hLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEuaXRlbXNbaWR4XSwganNvbltpZHhdKTtcbiAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWlnaHQgYmUgYm9vbGVhbiwgc28gY2hlY2sgdGhhdCBpdCdzIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGUuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMsIGpzb25baWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgLy8gSWYgaXRlbXMgaXMgYSBzY2hlbWEsIHRoZW4gdGhlIGNoaWxkIGluc3RhbmNlIG11c3QgYmUgdmFsaWQgYWdhaW5zdCB0aGlzIHNjaGVtYSxcbiAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiBpdHMgaW5kZXgsIGFuZCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBcImFkZGl0aW9uYWxJdGVtc1wiLlxuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goaWR4KTtcbiAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGUuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYS5pdGVtcywganNvbltpZHhdKTtcbiAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG52YXIgcmVjdXJzZU9iamVjdCA9IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi44LjNcblxuICAgIC8vIElmIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiBpcyBhYnNlbnQsIGl0IGlzIGNvbnNpZGVyZWQgcHJlc2VudCB3aXRoIGFuIGVtcHR5IHNjaGVtYSBhcyBhIHZhbHVlLlxuICAgIC8vIEluIGFkZGl0aW9uLCBib29sZWFuIHZhbHVlIHRydWUgaXMgY29uc2lkZXJlZCBlcXVpdmFsZW50IHRvIGFuIGVtcHR5IHNjaGVtYS5cbiAgICB2YXIgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB0cnVlIHx8IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBwIC0gVGhlIHByb3BlcnR5IHNldCBmcm9tIFwicHJvcGVydGllc1wiLlxuICAgIHZhciBwID0gc2NoZW1hLnByb3BlcnRpZXMgPyBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykgOiBbXTtcblxuICAgIC8vIHBwIC0gVGhlIHByb3BlcnR5IHNldCBmcm9tIFwicGF0dGVyblByb3BlcnRpZXNcIi4gRWxlbWVudHMgb2YgdGhpcyBzZXQgd2lsbCBiZSBjYWxsZWQgcmVnZXhlcyBmb3IgY29udmVuaWVuY2UuXG4gICAgdmFyIHBwID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzID8gT2JqZWN0LmtleXMoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSA6IFtdO1xuXG4gICAgLy8gbSAtIFRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBjaGlsZC5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGpzb24pLFxuICAgICAgICBpZHggPSBrZXlzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICB2YXIgbSA9IGtleXNbaWR4XSxcbiAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSBqc29uW21dO1xuXG4gICAgICAgIC8vIHMgLSBUaGUgc2V0IG9mIHNjaGVtYXMgZm9yIHRoZSBjaGlsZCBpbnN0YW5jZS5cbiAgICAgICAgdmFyIHMgPSBbXTtcblxuICAgICAgICAvLyAxLiBJZiBzZXQgXCJwXCIgY29udGFpbnMgdmFsdWUgXCJtXCIsIHRoZW4gdGhlIGNvcnJlc3BvbmRpbmcgc2NoZW1hIGluIFwicHJvcGVydGllc1wiIGlzIGFkZGVkIHRvIFwic1wiLlxuICAgICAgICBpZiAocC5pbmRleE9mKG0pICE9PSAtMSkge1xuICAgICAgICAgICAgcy5wdXNoKHNjaGVtYS5wcm9wZXJ0aWVzW21dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIEZvciBlYWNoIHJlZ2V4IGluIFwicHBcIiwgaWYgaXQgbWF0Y2hlcyBcIm1cIiBzdWNjZXNzZnVsbHksIHRoZSBjb3JyZXNwb25kaW5nIHNjaGVtYSBpbiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIgaXMgYWRkZWQgdG8gXCJzXCIuXG4gICAgICAgIHZhciBpZHgyID0gcHAubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4Mi0tKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhTdHJpbmcgPSBwcFtpZHgyXTtcbiAgICAgICAgICAgIGlmIChSZWdFeHAocmVnZXhTdHJpbmcpLnRlc3QobSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzLnB1c2goc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3JlZ2V4U3RyaW5nXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBUaGUgc2NoZW1hIGRlZmluZWQgYnkgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiIGlzIGFkZGVkIHRvIFwic1wiIGlmIGFuZCBvbmx5IGlmLCBhdCB0aGlzIHN0YWdlLCBcInNcIiBpcyBlbXB0eS5cbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwICYmIGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcy5wdXNoKGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGFyZSBwYXNzaW5nIHRlc3RzIGV2ZW4gd2l0aG91dCB0aGlzIGFzc2VydCBiZWNhdXNlIHRoaXMgaXMgY292ZXJlZCBieSBwcm9wZXJ0aWVzIGNoZWNrXG4gICAgICAgIC8vIGlmIHMgaXMgZW1wdHkgaW4gdGhpcyBzdGFnZSwgbm8gYWRkaXRpb25hbFByb3BlcnRpZXMgYXJlIGFsbG93ZWRcbiAgICAgICAgLy8gcmVwb3J0LmV4cGVjdChzLmxlbmd0aCAhPT0gMCwgJ0UwMDEnLCBtKTtcblxuICAgICAgICAvLyBJbnN0YW5jZSBwcm9wZXJ0eSB2YWx1ZSBtdXN0IHBhc3MgYWxsIHNjaGVtYXMgZnJvbSBzXG4gICAgICAgIGlkeDIgPSBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeDItLSkge1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChtKTtcbiAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGUuY2FsbCh0aGlzLCByZXBvcnQsIHNbaWR4Ml0sIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnRzLkpzb25WYWxpZGF0b3JzID0gSnNvblZhbGlkYXRvcnM7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7UmVwb3J0fSByZXBvcnRcbiAqIEBwYXJhbSB7Kn0gc2NoZW1hXG4gKiBAcGFyYW0geyp9IGpzb25cbiAqL1xuZXhwb3J0cy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSwganNvbikge1xuXG4gICAgcmVwb3J0LmNvbW1vbkVycm9yTWVzc2FnZSA9IFwiSlNPTl9PQkpFQ1RfVkFMSURBVElPTl9GQUlMRURcIjtcblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtYSBpcyBhbiBvYmplY3RcbiAgICB2YXIgdG8gPSBVdGlscy53aGF0SXMoc2NoZW1hKTtcbiAgICBpZiAodG8gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiU0NIRU1BX05PVF9BTl9PQkpFQ1RcIiwgW3RvXSwgbnVsbCwgc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtYSBpcyBlbXB0eSwgZXZlcnl0aGluZyBpcyB2YWxpZCBhZ2FpbnN0IGVtcHR5IHNjaGVtYVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCByZWN1cnNpdmVseSwgc28gd2UgbmVlZCB0byByZW1lbWJlciBvdXIgcm9vdFxuICAgIHZhciBpc1Jvb3QgPSBmYWxzZTtcbiAgICBpZiAoIXJlcG9ydC5yb290U2NoZW1hKSB7XG4gICAgICAgIHJlcG9ydC5yb290U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBpc1Jvb3QgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZvbGxvdyBzY2hlbWEuJHJlZiBrZXlzXG4gICAgaWYgKHNjaGVtYS4kcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYXZvaWQgaW5maW5pdGUgbG9vcCB3aXRoIG1heFJlZnNcbiAgICAgICAgdmFyIG1heFJlZnMgPSA5OTtcbiAgICAgICAgd2hpbGUgKHNjaGVtYS4kcmVmICYmIG1heFJlZnMgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fXyRyZWZSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIlJFRl9VTlJFU09MVkVEXCIsIFtzY2hlbWEuJHJlZl0sIG51bGwsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5fXyRyZWZSZXNvbHZlZCA9PT0gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fXyRyZWZSZXNvbHZlZDtcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1heFJlZnMtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4UmVmcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgZGVwZW5kZW5jeSBieSAkcmVmIHJlZmVyZW5jZXMhXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHlwZSBjaGVja2luZyBmaXJzdFxuICAgIHZhciBqc29uVHlwZSA9IFV0aWxzLndoYXRJcyhqc29uKTtcbiAgICBpZiAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKFwidHlwZVwiKSwgMSk7XG4gICAgICAgIEpzb25WYWxpZGF0b3JzLnR5cGUuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSwganNvbik7XG4gICAgICAgIGlmIChyZXBvcnQuZXJyb3JzLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuYnJlYWtPbkZpcnN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyBpdGVyYXRlIGFsbCB0aGUga2V5cyBpbiBzY2hlbWEgYW5kIGV4ZWN1dGUgdmFsaWRhdGlvbiBtZXRob2RzXG4gICAgdmFyIGlkeCA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICBpZiAoSnNvblZhbGlkYXRvcnNba2V5c1tpZHhdXSkge1xuICAgICAgICAgICAgSnNvblZhbGlkYXRvcnNba2V5c1tpZHhdXS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hLCBqc29uKTtcbiAgICAgICAgICAgIGlmIChyZXBvcnQuZXJyb3JzLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuYnJlYWtPbkZpcnN0RXJyb3IpIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXBvcnQuZXJyb3JzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLm9wdGlvbnMuYnJlYWtPbkZpcnN0RXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChqc29uVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICByZWN1cnNlQXJyYXkuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSwganNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoanNvblR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJlY3Vyc2VPYmplY3QuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSwganNvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jdXN0b21WYWxpZGF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY3VzdG9tVmFsaWRhdG9yLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEsIGpzb24pO1xuICAgIH1cblxuICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIHJvb3QgcG9pbnRlciBhbnltb3JlXG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZXBvcnQucm9vdFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdmFsaWQganVzdCB0byBiZSBhYmxlIHRvIGJyZWFrIGF0IHNvbWUgY29kZSBwb2ludHNcbiAgICByZXR1cm4gcmVwb3J0LmVycm9ycy5sZW5ndGggPT09IDA7XG5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/JsonValidation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/Polyfills.js":
/*!************************************************!*\
  !*** ./node_modules/z-schema/src/Polyfills.js ***!
  \************************************************/
/***/ (() => {

eval("// Number.isFinite polyfill\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite\nif (typeof Number.isFinite !== \"function\") {\n    Number.isFinite = function isFinite(value) {\n        // 1. If Type(number) is not Number, return false.\n        if (typeof value !== \"number\") {\n            return false;\n        }\n        // 2. If number is NaN, +, or , return false.\n        if (value !== value || value === Infinity || value === -Infinity) {\n            return false;\n        }\n        // 3. Otherwise, return true.\n        return true;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1BvbHlmaWxscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFx6LXNjaGVtYVxcc3JjXFxQb2x5ZmlsbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTnVtYmVyLmlzRmluaXRlIHBvbHlmaWxsXG4vLyBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIuaXNmaW5pdGVcbmlmICh0eXBlb2YgTnVtYmVyLmlzRmluaXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBOdW1iZXIuaXNGaW5pdGUgPSBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgICAvLyAxLiBJZiBUeXBlKG51bWJlcikgaXMgbm90IE51bWJlciwgcmV0dXJuIGZhbHNlLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gSWYgbnVtYmVyIGlzIE5hTiwgK+KIniwgb3Ig4oiS4oieLCByZXR1cm4gZmFsc2UuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiB0cnVlLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/Polyfills.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/Report.js":
/*!*********************************************!*\
  !*** ./node_modules/z-schema/src/Report.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar get    = __webpack_require__(/*! lodash.get */ \"(rsc)/./node_modules/lodash.get/index.js\");\nvar Errors = __webpack_require__(/*! ./Errors */ \"(rsc)/./node_modules/z-schema/src/Errors.js\");\nvar Utils  = __webpack_require__(/*! ./Utils */ \"(rsc)/./node_modules/z-schema/src/Utils.js\");\n\n/**\n * @class\n *\n * @param {Report|object} parentOrOptions\n * @param {object} [reportOptions]\n */\nfunction Report(parentOrOptions, reportOptions) {\n    this.parentReport = parentOrOptions instanceof Report ?\n                            parentOrOptions :\n                            undefined;\n\n    this.options = parentOrOptions instanceof Report ?\n                       parentOrOptions.options :\n                       parentOrOptions || {};\n\n    this.reportOptions = reportOptions || {};\n\n    this.errors = [];\n    /**\n     * @type {string[]}\n     */\n    this.path = [];\n    this.asyncTasks = [];\n\n    this.rootSchema = undefined;\n    this.commonErrorMessage = undefined;\n    this.json = undefined;\n}\n\n/**\n * @returns {boolean}\n */\nReport.prototype.isValid = function () {\n    if (this.asyncTasks.length > 0) {\n        throw new Error(\"Async tasks pending, can't answer isValid\");\n    }\n    return this.errors.length === 0;\n};\n\n/**\n *\n * @param {*} fn\n * @param {*} args\n * @param {*} asyncTaskResultProcessFn\n */\nReport.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {\n    this.asyncTasks.push([fn, args, asyncTaskResultProcessFn]);\n};\n\nReport.prototype.getAncestor = function (id) {\n    if (!this.parentReport) {\n        return undefined;\n    }\n    if (this.parentReport.getSchemaId() === id) {\n        return this.parentReport;\n    }\n    return this.parentReport.getAncestor(id);\n};\n\n/**\n *\n * @param {*} timeout\n * @param {function(*, *)} callback\n *\n * @returns {void}\n */\nReport.prototype.processAsyncTasks = function (timeout, callback) {\n\n    var validationTimeout = timeout || 2000,\n        tasksCount        = this.asyncTasks.length,\n        idx               = tasksCount,\n        timedOut          = false,\n        self              = this;\n\n    function finish() {\n        process.nextTick(function () {\n            var valid = self.errors.length === 0,\n                err = valid ? null : self.errors;\n            callback(err, valid);\n        });\n    }\n\n    function respond(asyncTaskResultProcessFn) {\n        return function (asyncTaskResult) {\n            if (timedOut) { return; }\n            asyncTaskResultProcessFn(asyncTaskResult);\n            if (--tasksCount === 0) {\n                finish();\n            }\n        };\n    }\n\n    // finish if tasks are completed or there are any errors and breaking on first error was requested\n    if (tasksCount === 0 || (this.errors.length > 0 && this.options.breakOnFirstError)) {\n        finish();\n        return;\n    }\n\n    while (idx--) {\n        var task = this.asyncTasks[idx];\n        task[0].apply(null, task[1].concat(respond(task[2])));\n    }\n\n    setTimeout(function () {\n        if (tasksCount > 0) {\n            timedOut = true;\n            self.addError(\"ASYNC_TIMEOUT\", [tasksCount, validationTimeout]);\n            callback(self.errors, false);\n        }\n    }, validationTimeout);\n\n};\n\n/**\n *\n * @param {*} returnPathAsString\n *\n * @return {string[]|string}\n */\nReport.prototype.getPath = function (returnPathAsString) {\n    /**\n     * @type {string[]|string}\n     */\n    var path = [];\n    if (this.parentReport) {\n        path = path.concat(this.parentReport.path);\n    }\n    path = path.concat(this.path);\n\n    if (returnPathAsString !== true) {\n        // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)\n        path = \"#/\" + path.map(function (segment) {\n            segment = segment.toString();\n\n            if (Utils.isAbsoluteUri(segment)) {\n                return \"uri(\" + segment + \")\";\n            }\n\n            return segment.replace(/\\~/g, \"~0\").replace(/\\//g, \"~1\");\n        }).join(\"/\");\n    }\n    return path;\n};\n\nReport.prototype.getSchemaId = function () {\n\n    if (!this.rootSchema) {\n        return null;\n    }\n\n    // get the error path as an array\n    var path = [];\n    if (this.parentReport) {\n        path = path.concat(this.parentReport.path);\n    }\n    path = path.concat(this.path);\n\n    // try to find id in the error path\n    while (path.length > 0) {\n        var obj = get(this.rootSchema, path);\n        if (obj && obj.id) { return obj.id; }\n        path.pop();\n    }\n\n    // return id of the root\n    return this.rootSchema.id;\n};\n\n/**\n *\n * @param {*} errorCode\n * @param {*} params\n *\n * @return {boolean}\n */\nReport.prototype.hasError = function (errorCode, params) {\n    var idx = this.errors.length;\n    while (idx--) {\n        if (this.errors[idx].code === errorCode) {\n            // assume match\n            var match = true;\n\n            // check the params too\n            var idx2 = this.errors[idx].params.length;\n            while (idx2--) {\n                if (this.errors[idx].params[idx2] !== params[idx2]) {\n                    match = false;\n                }\n            }\n\n            // if match, return true\n            if (match) { return match; }\n        }\n    }\n    return false;\n};\n\n/**\n *\n * @param {*} errorCode\n * @param {*} params\n * @param {Report[]|Report} [subReports]\n * @param {*} [schema]\n *\n * @return {void}\n */\nReport.prototype.addError = function (errorCode, params, subReports, schema) {\n    if (!errorCode) { throw new Error(\"No errorCode passed into addError()\"); }\n\n    this.addCustomError(errorCode, Errors[errorCode], params, subReports, schema);\n};\n\nReport.prototype.getJson = function () {\n    var self = this;\n    while (self.json === undefined) {\n        self = self.parentReport;\n        if (self === undefined) {\n            return undefined;\n        }\n    }\n    return self.json;\n};\n\n/**\n *\n * @param {*} errorCode\n * @param {*} errorMessage\n * @param {*[]} params\n * @param {Report[]|Report} subReports\n * @param {*} schema\n *\n * @returns {void}\n */\nReport.prototype.addCustomError = function (errorCode, errorMessage, params, subReports, schema) {\n    if (this.errors.length >= this.reportOptions.maxErrors) {\n        return;\n    }\n\n    if (!errorMessage) { throw new Error(\"No errorMessage known for code \" + errorCode); }\n\n    params = params || [];\n\n    var idx = params.length;\n    while (idx--) {\n        var whatIs = Utils.whatIs(params[idx]);\n        var param = (whatIs === \"object\" || whatIs === \"null\") ? JSON.stringify(params[idx]) : params[idx];\n        errorMessage = errorMessage.replace(\"{\" + idx + \"}\", param);\n    }\n\n    var err = {\n        code: errorCode,\n        params: params,\n        message: errorMessage,\n        path: this.getPath(this.options.reportPathAsArray),\n        schemaId: this.getSchemaId()\n    };\n\n    err[Utils.schemaSymbol] = schema;\n    err[Utils.jsonSymbol] = this.getJson();\n\n    if (schema && typeof schema === \"string\") {\n        err.description = schema;\n    } else if (schema && typeof schema === \"object\") {\n        if (schema.title) {\n            err.title = schema.title;\n        }\n        if (schema.description) {\n            err.description = schema.description;\n        }\n    }\n\n    if (subReports != null) {\n        if (!Array.isArray(subReports)) {\n            subReports = [subReports];\n        }\n        err.inner = [];\n        idx = subReports.length;\n        while (idx--) {\n            var subReport = subReports[idx],\n                idx2 = subReport.errors.length;\n            while (idx2--) {\n                err.inner.push(subReport.errors[idx2]);\n            }\n        }\n        if (err.inner.length === 0) {\n            err.inner = undefined;\n        }\n    }\n\n    this.errors.push(err);\n};\n\nmodule.exports = Report;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1JlcG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNERBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDZEQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywyREFBUzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsR0FBRztBQUNkO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEhhcnl1NTQxMlxcRGVza3RvcFxcU2Nob29sXFxjYXBzdG9uZVxccGljc2VsXFxiYWNrZW5kXFxub2RlX21vZHVsZXNcXHotc2NoZW1hXFxzcmNcXFJlcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdldCAgICA9IHJlcXVpcmUoXCJsb2Rhc2guZ2V0XCIpO1xudmFyIEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9yc1wiKTtcbnZhciBVdGlscyAgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge1JlcG9ydHxvYmplY3R9IHBhcmVudE9yT3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtyZXBvcnRPcHRpb25zXVxuICovXG5mdW5jdGlvbiBSZXBvcnQocGFyZW50T3JPcHRpb25zLCByZXBvcnRPcHRpb25zKSB7XG4gICAgdGhpcy5wYXJlbnRSZXBvcnQgPSBwYXJlbnRPck9wdGlvbnMgaW5zdGFuY2VvZiBSZXBvcnQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE9yT3B0aW9ucyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5vcHRpb25zID0gcGFyZW50T3JPcHRpb25zIGluc3RhbmNlb2YgUmVwb3J0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50T3JPcHRpb25zLm9wdGlvbnMgOlxuICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRPck9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnJlcG9ydE9wdGlvbnMgPSByZXBvcnRPcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5wYXRoID0gW107XG4gICAgdGhpcy5hc3luY1Rhc2tzID0gW107XG5cbiAgICB0aGlzLnJvb3RTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb21tb25FcnJvck1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5qc29uID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5SZXBvcnQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYXN5bmNUYXNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHRhc2tzIHBlbmRpbmcsIGNhbid0IGFuc3dlciBpc1ZhbGlkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lcnJvcnMubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBmblxuICogQHBhcmFtIHsqfSBhcmdzXG4gKiBAcGFyYW0geyp9IGFzeW5jVGFza1Jlc3VsdFByb2Nlc3NGblxuICovXG5SZXBvcnQucHJvdG90eXBlLmFkZEFzeW5jVGFzayA9IGZ1bmN0aW9uIChmbiwgYXJncywgYXN5bmNUYXNrUmVzdWx0UHJvY2Vzc0ZuKSB7XG4gICAgdGhpcy5hc3luY1Rhc2tzLnB1c2goW2ZuLCBhcmdzLCBhc3luY1Rhc2tSZXN1bHRQcm9jZXNzRm5dKTtcbn07XG5cblJlcG9ydC5wcm90b3R5cGUuZ2V0QW5jZXN0b3IgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50UmVwb3J0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudFJlcG9ydC5nZXRTY2hlbWFJZCgpID09PSBpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRSZXBvcnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcmVudFJlcG9ydC5nZXRBbmNlc3RvcihpZCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IHRpbWVvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKil9IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblJlcG9ydC5wcm90b3R5cGUucHJvY2Vzc0FzeW5jVGFza3MgPSBmdW5jdGlvbiAodGltZW91dCwgY2FsbGJhY2spIHtcblxuICAgIHZhciB2YWxpZGF0aW9uVGltZW91dCA9IHRpbWVvdXQgfHwgMjAwMCxcbiAgICAgICAgdGFza3NDb3VudCAgICAgICAgPSB0aGlzLmFzeW5jVGFza3MubGVuZ3RoLFxuICAgICAgICBpZHggICAgICAgICAgICAgICA9IHRhc2tzQ291bnQsXG4gICAgICAgIHRpbWVkT3V0ICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgIHNlbGYgICAgICAgICAgICAgID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSBzZWxmLmVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICAgICAgZXJyID0gdmFsaWQgPyBudWxsIDogc2VsZi5lcnJvcnM7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzcG9uZChhc3luY1Rhc2tSZXN1bHRQcm9jZXNzRm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhc3luY1Rhc2tSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aW1lZE91dCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGFzeW5jVGFza1Jlc3VsdFByb2Nlc3NGbihhc3luY1Rhc2tSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKC0tdGFza3NDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZpbmlzaCBpZiB0YXNrcyBhcmUgY29tcGxldGVkIG9yIHRoZXJlIGFyZSBhbnkgZXJyb3JzIGFuZCBicmVha2luZyBvbiBmaXJzdCBlcnJvciB3YXMgcmVxdWVzdGVkXG4gICAgaWYgKHRhc2tzQ291bnQgPT09IDAgfHwgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDAgJiYgdGhpcy5vcHRpb25zLmJyZWFrT25GaXJzdEVycm9yKSkge1xuICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICB2YXIgdGFzayA9IHRoaXMuYXN5bmNUYXNrc1tpZHhdO1xuICAgICAgICB0YXNrWzBdLmFwcGx5KG51bGwsIHRhc2tbMV0uY29uY2F0KHJlc3BvbmQodGFza1syXSkpKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhc2tzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmFkZEVycm9yKFwiQVNZTkNfVElNRU9VVFwiLCBbdGFza3NDb3VudCwgdmFsaWRhdGlvblRpbWVvdXRdKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYuZXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCB2YWxpZGF0aW9uVGltZW91dCk7XG5cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gcmV0dXJuUGF0aEFzU3RyaW5nXG4gKlxuICogQHJldHVybiB7c3RyaW5nW118c3RyaW5nfVxuICovXG5SZXBvcnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAocmV0dXJuUGF0aEFzU3RyaW5nKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ1tdfHN0cmluZ31cbiAgICAgKi9cbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIGlmICh0aGlzLnBhcmVudFJlcG9ydCkge1xuICAgICAgICBwYXRoID0gcGF0aC5jb25jYXQodGhpcy5wYXJlbnRSZXBvcnQucGF0aCk7XG4gICAgfVxuICAgIHBhdGggPSBwYXRoLmNvbmNhdCh0aGlzLnBhdGgpO1xuXG4gICAgaWYgKHJldHVyblBhdGhBc1N0cmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBTYW5pdGl6ZSB0aGUgcGF0aCBzZWdtZW50cyAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMSNzZWN0aW9uLTQpXG4gICAgICAgIHBhdGggPSBcIiMvXCIgKyBwYXRoLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzQWJzb2x1dGVVcmkoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ1cmkoXCIgKyBzZWdtZW50ICsgXCIpXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuICAgICAgICB9KS5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5SZXBvcnQucHJvdG90eXBlLmdldFNjaGVtYUlkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCF0aGlzLnJvb3RTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBlcnJvciBwYXRoIGFzIGFuIGFycmF5XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICBpZiAodGhpcy5wYXJlbnRSZXBvcnQpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KHRoaXMucGFyZW50UmVwb3J0LnBhdGgpO1xuICAgIH1cbiAgICBwYXRoID0gcGF0aC5jb25jYXQodGhpcy5wYXRoKTtcblxuICAgIC8vIHRyeSB0byBmaW5kIGlkIGluIHRoZSBlcnJvciBwYXRoXG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgb2JqID0gZ2V0KHRoaXMucm9vdFNjaGVtYSwgcGF0aCk7XG4gICAgICAgIGlmIChvYmogJiYgb2JqLmlkKSB7IHJldHVybiBvYmouaWQ7IH1cbiAgICAgICAgcGF0aC5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gaWQgb2YgdGhlIHJvb3RcbiAgICByZXR1cm4gdGhpcy5yb290U2NoZW1hLmlkO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBlcnJvckNvZGVcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhcmFtcykge1xuICAgIHZhciBpZHggPSB0aGlzLmVycm9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yc1tpZHhdLmNvZGUgPT09IGVycm9yQ29kZSkge1xuICAgICAgICAgICAgLy8gYXNzdW1lIG1hdGNoXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgcGFyYW1zIHRvb1xuICAgICAgICAgICAgdmFyIGlkeDIgPSB0aGlzLmVycm9yc1tpZHhdLnBhcmFtcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaWR4Mi0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JzW2lkeF0ucGFyYW1zW2lkeDJdICE9PSBwYXJhbXNbaWR4Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIG1hdGNoLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7IHJldHVybiBtYXRjaDsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gZXJyb3JDb2RlXG4gKiBAcGFyYW0geyp9IHBhcmFtc1xuICogQHBhcmFtIHtSZXBvcnRbXXxSZXBvcnR9IFtzdWJSZXBvcnRzXVxuICogQHBhcmFtIHsqfSBbc2NoZW1hXVxuICpcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuYWRkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXJhbXMsIHN1YlJlcG9ydHMsIHNjaGVtYSkge1xuICAgIGlmICghZXJyb3JDb2RlKSB7IHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yQ29kZSBwYXNzZWQgaW50byBhZGRFcnJvcigpXCIpOyB9XG5cbiAgICB0aGlzLmFkZEN1c3RvbUVycm9yKGVycm9yQ29kZSwgRXJyb3JzW2Vycm9yQ29kZV0sIHBhcmFtcywgc3ViUmVwb3J0cywgc2NoZW1hKTtcbn07XG5cblJlcG9ydC5wcm90b3R5cGUuZ2V0SnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgd2hpbGUgKHNlbGYuanNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLnBhcmVudFJlcG9ydDtcbiAgICAgICAgaWYgKHNlbGYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZi5qc29uO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBlcnJvckNvZGVcbiAqIEBwYXJhbSB7Kn0gZXJyb3JNZXNzYWdlXG4gKiBAcGFyYW0geypbXX0gcGFyYW1zXG4gKiBAcGFyYW0ge1JlcG9ydFtdfFJlcG9ydH0gc3ViUmVwb3J0c1xuICogQHBhcmFtIHsqfSBzY2hlbWFcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZS5hZGRDdXN0b21FcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgcGFyYW1zLCBzdWJSZXBvcnRzLCBzY2hlbWEpIHtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID49IHRoaXMucmVwb3J0T3B0aW9ucy5tYXhFcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZXJyb3JNZXNzYWdlKSB7IHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yTWVzc2FnZSBrbm93biBmb3IgY29kZSBcIiArIGVycm9yQ29kZSk7IH1cblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCBbXTtcblxuICAgIHZhciBpZHggPSBwYXJhbXMubGVuZ3RoO1xuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICB2YXIgd2hhdElzID0gVXRpbHMud2hhdElzKHBhcmFtc1tpZHhdKTtcbiAgICAgICAgdmFyIHBhcmFtID0gKHdoYXRJcyA9PT0gXCJvYmplY3RcIiB8fCB3aGF0SXMgPT09IFwibnVsbFwiKSA/IEpTT04uc3RyaW5naWZ5KHBhcmFtc1tpZHhdKSA6IHBhcmFtc1tpZHhdO1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2UucmVwbGFjZShcIntcIiArIGlkeCArIFwifVwiLCBwYXJhbSk7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICBwYXRoOiB0aGlzLmdldFBhdGgodGhpcy5vcHRpb25zLnJlcG9ydFBhdGhBc0FycmF5KSxcbiAgICAgICAgc2NoZW1hSWQ6IHRoaXMuZ2V0U2NoZW1hSWQoKVxuICAgIH07XG5cbiAgICBlcnJbVXRpbHMuc2NoZW1hU3ltYm9sXSA9IHNjaGVtYTtcbiAgICBlcnJbVXRpbHMuanNvblN5bWJvbF0gPSB0aGlzLmdldEpzb24oKTtcblxuICAgIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlcnIuZGVzY3JpcHRpb24gPSBzY2hlbWE7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoc2NoZW1hLnRpdGxlKSB7XG4gICAgICAgICAgICBlcnIudGl0bGUgPSBzY2hlbWEudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgZXJyLmRlc2NyaXB0aW9uID0gc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1YlJlcG9ydHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3ViUmVwb3J0cykpIHtcbiAgICAgICAgICAgIHN1YlJlcG9ydHMgPSBbc3ViUmVwb3J0c107XG4gICAgICAgIH1cbiAgICAgICAgZXJyLmlubmVyID0gW107XG4gICAgICAgIGlkeCA9IHN1YlJlcG9ydHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIHZhciBzdWJSZXBvcnQgPSBzdWJSZXBvcnRzW2lkeF0sXG4gICAgICAgICAgICAgICAgaWR4MiA9IHN1YlJlcG9ydC5lcnJvcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeDItLSkge1xuICAgICAgICAgICAgICAgIGVyci5pbm5lci5wdXNoKHN1YlJlcG9ydC5lcnJvcnNbaWR4Ml0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIuaW5uZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnIuaW5uZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcG9ydDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/Report.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/SchemaCache.js":
/*!**************************************************!*\
  !*** ./node_modules/z-schema/src/SchemaCache.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isequal             = __webpack_require__(/*! lodash.isequal */ \"(rsc)/./node_modules/lodash.isequal/index.js\");\nvar Report              = __webpack_require__(/*! ./Report */ \"(rsc)/./node_modules/z-schema/src/Report.js\");\nvar SchemaCompilation   = __webpack_require__(/*! ./SchemaCompilation */ \"(rsc)/./node_modules/z-schema/src/SchemaCompilation.js\");\nvar SchemaValidation    = __webpack_require__(/*! ./SchemaValidation */ \"(rsc)/./node_modules/z-schema/src/SchemaValidation.js\");\nvar Utils               = __webpack_require__(/*! ./Utils */ \"(rsc)/./node_modules/z-schema/src/Utils.js\");\n\nfunction decodeJSONPointer(str) {\n    // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3\n    return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {\n        return x === \"~1\" ? \"/\" : \"~\";\n    });\n}\n\nfunction getRemotePath(uri) {\n    var io = uri.indexOf(\"#\");\n    return io === -1 ? uri : uri.slice(0, io);\n}\n\nfunction getQueryPath(uri) {\n    var io = uri.indexOf(\"#\");\n    var res = io === -1 ? undefined : uri.slice(io + 1);\n    // WARN: do not slice slash, #/ means take root and go down from it\n    // if (res && res[0] === \"/\") { res = res.slice(1); }\n    return res;\n}\n\nfunction findId(schema, id) {\n    // process only arrays and objects\n    if (typeof schema !== \"object\" || schema === null) {\n        return;\n    }\n\n    // no id means root so return itself\n    if (!id) {\n        return schema;\n    }\n\n    if (schema.id) {\n        if (schema.id === id || schema.id[0] === \"#\" && schema.id.substring(1) === id) {\n            return schema;\n        }\n    }\n\n    var idx, result;\n    if (Array.isArray(schema)) {\n        idx = schema.length;\n        while (idx--) {\n            result = findId(schema[idx], id);\n            if (result) { return result; }\n        }\n    } else {\n        var keys = Object.keys(schema);\n        idx = keys.length;\n        while (idx--) {\n            var k = keys[idx];\n            if (k.indexOf(\"__$\") === 0) {\n                continue;\n            }\n            result = findId(schema[k], id);\n            if (result) { return result; }\n        }\n    }\n}\n\n/**\n *\n * @param {*} uri\n * @param {*} schema\n *\n * @returns {void}\n */\nexports.cacheSchemaByUri = function (uri, schema) {\n    var remotePath = getRemotePath(uri);\n    if (remotePath) {\n        this.cache[remotePath] = schema;\n    }\n};\n\n/**\n *\n * @param {*} uri\n *\n * @returns {void}\n */\nexports.removeFromCacheByUri = function (uri) {\n    var remotePath = getRemotePath(uri);\n    if (remotePath) {\n        delete this.cache[remotePath];\n    }\n};\n\n/**\n *\n * @param {*} uri\n *\n * @returns {boolean}\n */\nexports.checkCacheForUri = function (uri) {\n    var remotePath = getRemotePath(uri);\n    return remotePath ? this.cache[remotePath] != null : false;\n};\n\nexports.getSchema = function (report, schema) {\n    if (typeof schema === \"object\") {\n        schema = exports.getSchemaByReference.call(this, report, schema);\n    }\n    if (typeof schema === \"string\") {\n        schema = exports.getSchemaByUri.call(this, report, schema);\n    }\n    return schema;\n};\n\nexports.getSchemaByReference = function (report, key) {\n    var i = this.referenceCache.length;\n    while (i--) {\n        if (isequal(this.referenceCache[i][0], key)) {\n            return this.referenceCache[i][1];\n        }\n    }\n    // not found\n    var schema = Utils.cloneDeep(key);\n    this.referenceCache.push([key, schema]);\n    return schema;\n};\n\nexports.getSchemaByUri = function (report, uri, root) {\n    var remotePath = getRemotePath(uri),\n        queryPath = getQueryPath(uri),\n        result = remotePath ? this.cache[remotePath] : root;\n\n    if (result && remotePath) {\n        // we need to avoid compiling schemas in a recursive loop\n        var compileRemote = result !== root;\n        // now we need to compile and validate resolved schema (in case it's not already)\n        if (compileRemote) {\n\n            report.path.push(remotePath);\n\n            var remoteReport;\n\n            var anscestorReport = report.getAncestor(result.id);\n            if (anscestorReport) {\n                remoteReport = anscestorReport;\n            } else {\n                remoteReport = new Report(report);\n                if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {\n                    var savedOptions = this.options;\n                    try {\n                        // If custom validationOptions were provided to setRemoteReference(),\n                        // use them instead of the default options\n                        this.options = result.__$validationOptions || this.options;\n                        SchemaValidation.validateSchema.call(this, remoteReport, result);\n                    } finally {\n                        this.options = savedOptions;\n                    }\n                }\n            }\n            var remoteReportIsValid = remoteReport.isValid();\n            if (!remoteReportIsValid) {\n                report.addError(\"REMOTE_NOT_VALID\", [uri], remoteReport);\n            }\n\n            report.path.pop();\n\n            if (!remoteReportIsValid) {\n                return undefined;\n            }\n        }\n    }\n\n    if (result && queryPath) {\n        var parts = queryPath.split(\"/\");\n        for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {\n            var key = decodeJSONPointer(parts[idx]);\n            if (idx === 0) { // it's an id\n                result = findId(result, key);\n            } else { // it's a path behind id\n                result = result[key];\n            }\n        }\n    }\n\n    return result;\n};\n\nexports.getRemotePath = getRemotePath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1NjaGVtYUNhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLG9FQUFnQjtBQUNsRCwwQkFBMEIsbUJBQU8sQ0FBQyw2REFBVTtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDdkQsMEJBQTBCLG1CQUFPLENBQUMsaUZBQW9CO0FBQ3RELDBCQUEwQixtQkFBTyxDQUFDLDJEQUFTOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFx6LXNjaGVtYVxcc3JjXFxTY2hlbWFDYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzZXF1YWwgICAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIik7XG52YXIgUmVwb3J0ICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1JlcG9ydFwiKTtcbnZhciBTY2hlbWFDb21waWxhdGlvbiAgID0gcmVxdWlyZShcIi4vU2NoZW1hQ29tcGlsYXRpb25cIik7XG52YXIgU2NoZW1hVmFsaWRhdGlvbiAgICA9IHJlcXVpcmUoXCIuL1NjaGVtYVZhbGlkYXRpb25cIik7XG52YXIgVXRpbHMgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuXG5mdW5jdGlvbiBkZWNvZGVKU09OUG9pbnRlcihzdHIpIHtcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLWFwcHNhd2ctanNvbi1wb2ludGVyLTA3I3NlY3Rpb24tM1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9+WzAtMV0vZywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IFwifjFcIiA/IFwiL1wiIDogXCJ+XCI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbW90ZVBhdGgodXJpKSB7XG4gICAgdmFyIGlvID0gdXJpLmluZGV4T2YoXCIjXCIpO1xuICAgIHJldHVybiBpbyA9PT0gLTEgPyB1cmkgOiB1cmkuc2xpY2UoMCwgaW8pO1xufVxuXG5mdW5jdGlvbiBnZXRRdWVyeVBhdGgodXJpKSB7XG4gICAgdmFyIGlvID0gdXJpLmluZGV4T2YoXCIjXCIpO1xuICAgIHZhciByZXMgPSBpbyA9PT0gLTEgPyB1bmRlZmluZWQgOiB1cmkuc2xpY2UoaW8gKyAxKTtcbiAgICAvLyBXQVJOOiBkbyBub3Qgc2xpY2Ugc2xhc2gsICMvIG1lYW5zIHRha2Ugcm9vdCBhbmQgZ28gZG93biBmcm9tIGl0XG4gICAgLy8gaWYgKHJlcyAmJiByZXNbMF0gPT09IFwiL1wiKSB7IHJlcyA9IHJlcy5zbGljZSgxKTsgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGZpbmRJZChzY2hlbWEsIGlkKSB7XG4gICAgLy8gcHJvY2VzcyBvbmx5IGFycmF5cyBhbmQgb2JqZWN0c1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSBcIm9iamVjdFwiIHx8IHNjaGVtYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm8gaWQgbWVhbnMgcm9vdCBzbyByZXR1cm4gaXRzZWxmXG4gICAgaWYgKCFpZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuaWQpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5pZCA9PT0gaWQgfHwgc2NoZW1hLmlkWzBdID09PSBcIiNcIiAmJiBzY2hlbWEuaWQuc3Vic3RyaW5nKDEpID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpZHgsIHJlc3VsdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgIGlkeCA9IHNjaGVtYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmluZElkKHNjaGVtYVtpZHhdLCBpZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICAgICAgaWR4ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2lkeF07XG4gICAgICAgICAgICBpZiAoay5pbmRleE9mKFwiX18kXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBmaW5kSWQoc2NoZW1hW2tdLCBpZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSB1cmlcbiAqIEBwYXJhbSB7Kn0gc2NoZW1hXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydHMuY2FjaGVTY2hlbWFCeVVyaSA9IGZ1bmN0aW9uICh1cmksIHNjaGVtYSkge1xuICAgIHZhciByZW1vdGVQYXRoID0gZ2V0UmVtb3RlUGF0aCh1cmkpO1xuICAgIGlmIChyZW1vdGVQYXRoKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbcmVtb3RlUGF0aF0gPSBzY2hlbWE7XG4gICAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSB1cmlcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0cy5yZW1vdmVGcm9tQ2FjaGVCeVVyaSA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICB2YXIgcmVtb3RlUGF0aCA9IGdldFJlbW90ZVBhdGgodXJpKTtcbiAgICBpZiAocmVtb3RlUGF0aCkge1xuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZVtyZW1vdGVQYXRoXTtcbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IHVyaVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmNoZWNrQ2FjaGVGb3JVcmkgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgdmFyIHJlbW90ZVBhdGggPSBnZXRSZW1vdGVQYXRoKHVyaSk7XG4gICAgcmV0dXJuIHJlbW90ZVBhdGggPyB0aGlzLmNhY2hlW3JlbW90ZVBhdGhdICE9IG51bGwgOiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgc2NoZW1hID0gZXhwb3J0cy5nZXRTY2hlbWFCeVJlZmVyZW5jZS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2NoZW1hID0gZXhwb3J0cy5nZXRTY2hlbWFCeVVyaS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbmV4cG9ydHMuZ2V0U2NoZW1hQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVwb3J0LCBrZXkpIHtcbiAgICB2YXIgaSA9IHRoaXMucmVmZXJlbmNlQ2FjaGUubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGlzZXF1YWwodGhpcy5yZWZlcmVuY2VDYWNoZVtpXVswXSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlQ2FjaGVbaV1bMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGZvdW5kXG4gICAgdmFyIHNjaGVtYSA9IFV0aWxzLmNsb25lRGVlcChrZXkpO1xuICAgIHRoaXMucmVmZXJlbmNlQ2FjaGUucHVzaChba2V5LCBzY2hlbWFdKTtcbiAgICByZXR1cm4gc2NoZW1hO1xufTtcblxuZXhwb3J0cy5nZXRTY2hlbWFCeVVyaSA9IGZ1bmN0aW9uIChyZXBvcnQsIHVyaSwgcm9vdCkge1xuICAgIHZhciByZW1vdGVQYXRoID0gZ2V0UmVtb3RlUGF0aCh1cmkpLFxuICAgICAgICBxdWVyeVBhdGggPSBnZXRRdWVyeVBhdGgodXJpKSxcbiAgICAgICAgcmVzdWx0ID0gcmVtb3RlUGF0aCA/IHRoaXMuY2FjaGVbcmVtb3RlUGF0aF0gOiByb290O1xuXG4gICAgaWYgKHJlc3VsdCAmJiByZW1vdGVQYXRoKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYXZvaWQgY29tcGlsaW5nIHNjaGVtYXMgaW4gYSByZWN1cnNpdmUgbG9vcFxuICAgICAgICB2YXIgY29tcGlsZVJlbW90ZSA9IHJlc3VsdCAhPT0gcm9vdDtcbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gY29tcGlsZSBhbmQgdmFsaWRhdGUgcmVzb2x2ZWQgc2NoZW1hIChpbiBjYXNlIGl0J3Mgbm90IGFscmVhZHkpXG4gICAgICAgIGlmIChjb21waWxlUmVtb3RlKSB7XG5cbiAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2gocmVtb3RlUGF0aCk7XG5cbiAgICAgICAgICAgIHZhciByZW1vdGVSZXBvcnQ7XG5cbiAgICAgICAgICAgIHZhciBhbnNjZXN0b3JSZXBvcnQgPSByZXBvcnQuZ2V0QW5jZXN0b3IocmVzdWx0LmlkKTtcbiAgICAgICAgICAgIGlmIChhbnNjZXN0b3JSZXBvcnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVSZXBvcnQgPSBhbnNjZXN0b3JSZXBvcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW90ZVJlcG9ydCA9IG5ldyBSZXBvcnQocmVwb3J0KTtcbiAgICAgICAgICAgICAgICBpZiAoU2NoZW1hQ29tcGlsYXRpb24uY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHJlbW90ZVJlcG9ydCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2F2ZWRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY3VzdG9tIHZhbGlkYXRpb25PcHRpb25zIHdlcmUgcHJvdmlkZWQgdG8gc2V0UmVtb3RlUmVmZXJlbmNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlbSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHJlc3VsdC5fXyR2YWxpZGF0aW9uT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBTY2hlbWFWYWxpZGF0aW9uLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVtb3RlUmVwb3J0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gc2F2ZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlbW90ZVJlcG9ydElzVmFsaWQgPSByZW1vdGVSZXBvcnQuaXNWYWxpZCgpO1xuICAgICAgICAgICAgaWYgKCFyZW1vdGVSZXBvcnRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiUkVNT1RFX05PVF9WQUxJRFwiLCBbdXJpXSwgcmVtb3RlUmVwb3J0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG5cbiAgICAgICAgICAgIGlmICghcmVtb3RlUmVwb3J0SXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ICYmIHF1ZXJ5UGF0aCkge1xuICAgICAgICB2YXIgcGFydHMgPSBxdWVyeVBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsaW0gPSBwYXJ0cy5sZW5ndGg7IHJlc3VsdCAmJiBpZHggPCBsaW07IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZGVjb2RlSlNPTlBvaW50ZXIocGFydHNbaWR4XSk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7IC8vIGl0J3MgYW4gaWRcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaW5kSWQocmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaXQncyBhIHBhdGggYmVoaW5kIGlkXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5nZXRSZW1vdGVQYXRoID0gZ2V0UmVtb3RlUGF0aDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/SchemaCache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/SchemaCompilation.js":
/*!********************************************************!*\
  !*** ./node_modules/z-schema/src/SchemaCompilation.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Report      = __webpack_require__(/*! ./Report */ \"(rsc)/./node_modules/z-schema/src/Report.js\");\nvar SchemaCache = __webpack_require__(/*! ./SchemaCache */ \"(rsc)/./node_modules/z-schema/src/SchemaCache.js\");\nvar Utils       = __webpack_require__(/*! ./Utils */ \"(rsc)/./node_modules/z-schema/src/Utils.js\");\n\nfunction mergeReference(scope, ref) {\n    if (Utils.isAbsoluteUri(ref)) {\n        return ref;\n    }\n\n    var joinedScope = scope.join(\"\"),\n        isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),\n        isScopeRelative = Utils.isRelativeUri(joinedScope),\n        isRefRelative = Utils.isRelativeUri(ref),\n        toRemove;\n\n    if (isScopeAbsolute && isRefRelative) {\n        toRemove = joinedScope.match(/\\/[^\\/]*$/);\n        if (toRemove) {\n            joinedScope = joinedScope.slice(0, toRemove.index + 1);\n        }\n    } else if (isScopeRelative && isRefRelative) {\n        joinedScope = \"\";\n    } else {\n        toRemove = joinedScope.match(/[^#/]+$/);\n        if (toRemove) {\n            joinedScope = joinedScope.slice(0, toRemove.index);\n        }\n    }\n\n    var res = joinedScope + ref;\n    res = res.replace(/##/, \"#\");\n    return res;\n}\n\nfunction collectReferences(obj, results, scope, path) {\n    results = results || [];\n    scope = scope || [];\n    path = path || [];\n\n    if (typeof obj !== \"object\" || obj === null) {\n        return results;\n    }\n\n    if (typeof obj.id === \"string\") {\n        scope.push(obj.id);\n    }\n\n    if (typeof obj.$ref === \"string\" && typeof obj.__$refResolved === \"undefined\") {\n        results.push({\n            ref: mergeReference(scope, obj.$ref),\n            key: \"$ref\",\n            obj: obj,\n            path: path.slice(0)\n        });\n    }\n    if (typeof obj.$schema === \"string\" && typeof obj.__$schemaResolved === \"undefined\") {\n        results.push({\n            ref: mergeReference(scope, obj.$schema),\n            key: \"$schema\",\n            obj: obj,\n            path: path.slice(0)\n        });\n    }\n\n    var idx;\n    if (Array.isArray(obj)) {\n        idx = obj.length;\n        while (idx--) {\n            path.push(idx.toString());\n            collectReferences(obj[idx], results, scope, path);\n            path.pop();\n        }\n    } else {\n        var keys = Object.keys(obj);\n        idx = keys.length;\n        while (idx--) {\n            // do not recurse through resolved references and other z-schema props\n            if (keys[idx].indexOf(\"__$\") === 0) { continue; }\n            path.push(keys[idx]);\n            collectReferences(obj[keys[idx]], results, scope, path);\n            path.pop();\n        }\n    }\n\n    if (typeof obj.id === \"string\") {\n        scope.pop();\n    }\n\n    return results;\n}\n\nvar compileArrayOfSchemasLoop = function (mainReport, arr) {\n    var idx = arr.length,\n        compiledCount = 0;\n\n    while (idx--) {\n\n        // try to compile each schema separately\n        var report = new Report(mainReport);\n        var isValid = exports.compileSchema.call(this, report, arr[idx]);\n        if (isValid) { compiledCount++; }\n\n        // copy errors to report\n        mainReport.errors = mainReport.errors.concat(report.errors);\n\n    }\n\n    return compiledCount;\n};\n\nfunction findId(arr, id) {\n    var idx = arr.length;\n    while (idx--) {\n        if (arr[idx].id === id) {\n            return arr[idx];\n        }\n    }\n    return null;\n}\n\nvar compileArrayOfSchemas = function (report, arr) {\n\n    var compiled = 0,\n        lastLoopCompiled;\n\n    do {\n\n        // remove all UNRESOLVABLE_REFERENCE errors before compiling array again\n        var idx = report.errors.length;\n        while (idx--) {\n            if (report.errors[idx].code === \"UNRESOLVABLE_REFERENCE\") {\n                report.errors.splice(idx, 1);\n            }\n        }\n\n        // remember how many were compiled in the last loop\n        lastLoopCompiled = compiled;\n\n        // count how many are compiled now\n        compiled = compileArrayOfSchemasLoop.call(this, report, arr);\n\n        // fix __$missingReferences if possible\n        idx = arr.length;\n        while (idx--) {\n            var sch = arr[idx];\n            if (sch.__$missingReferences) {\n                var idx2 = sch.__$missingReferences.length;\n                while (idx2--) {\n                    var refObj = sch.__$missingReferences[idx2];\n                    var response = findId(arr, refObj.ref);\n                    if (response) {\n                        // this might create circular references\n                        refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n                        // it's resolved now so delete it\n                        sch.__$missingReferences.splice(idx2, 1);\n                    }\n                }\n                if (sch.__$missingReferences.length === 0) {\n                    delete sch.__$missingReferences;\n                }\n            }\n        }\n\n        // keep repeating if not all compiled and at least one more was compiled in the last loop\n    } while (compiled !== arr.length && compiled !== lastLoopCompiled);\n\n    return report.isValid();\n\n};\n\nexports.compileSchema = function (report, schema) {\n\n    report.commonErrorMessage = \"SCHEMA_COMPILATION_FAILED\";\n\n    // if schema is a string, assume it's a uri\n    if (typeof schema === \"string\") {\n        var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);\n        if (!loadedSchema) {\n            report.addError(\"SCHEMA_NOT_REACHABLE\", [schema]);\n            return false;\n        }\n        schema = loadedSchema;\n    }\n\n    // if schema is an array, assume it's an array of schemas\n    if (Array.isArray(schema)) {\n        return compileArrayOfSchemas.call(this, report, schema);\n    }\n\n    // if we have an id than it should be cached already (if this instance has compiled it)\n    if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {\n        schema.__$compiled = undefined;\n    }\n\n    // do not re-compile schemas\n    if (schema.__$compiled) {\n        return true;\n    }\n\n    if (schema.id && typeof schema.id === \"string\") {\n        // add this to our schemaCache (before compilation in case we have references including id)\n        SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);\n    }\n\n    // this method can be called recursively, so we need to remember our root\n    var isRoot = false;\n    if (!report.rootSchema) {\n        report.rootSchema = schema;\n        isRoot = true;\n    }\n\n    // delete all __$missingReferences from previous compilation attempts\n    var isValidExceptReferences = report.isValid();\n    delete schema.__$missingReferences;\n\n    // collect all references that need to be resolved - $ref and $schema\n    var refs = collectReferences.call(this, schema),\n        idx = refs.length;\n    while (idx--) {\n        // resolve all the collected references into __xxxResolved pointer\n        var refObj = refs[idx];\n        var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n\n        // we can try to use custom schemaReader if available\n        if (!response) {\n            var schemaReader = this.getSchemaReader();\n            if (schemaReader) {\n                // it's supposed to return a valid schema\n                var s = schemaReader(refObj.ref);\n                if (s) {\n                    // it needs to have the id\n                    s.id = refObj.ref;\n                    // try to compile the schema\n                    var subreport = new Report(report);\n                    if (!exports.compileSchema.call(this, subreport, s)) {\n                        // copy errors to report\n                        report.errors = report.errors.concat(subreport.errors);\n                    } else {\n                        response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n                    }\n                }\n            }\n        }\n\n        if (!response) {\n\n            var hasNotValid = report.hasError(\"REMOTE_NOT_VALID\", [refObj.ref]);\n            var isAbsolute = Utils.isAbsoluteUri(refObj.ref);\n            var isDownloaded = false;\n            var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;\n\n            if (isAbsolute) {\n                // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded\n                // and set through setRemoteReference method\n                isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);\n            }\n\n            if (hasNotValid) {\n                // already has REMOTE_NOT_VALID error for this one\n            } else if (ignoreUnresolvableRemotes && isAbsolute) {\n                // ignoreUnresolvableRemotes is on and remote isAbsolute\n            } else if (isDownloaded) {\n                // remote is downloaded, so no UNRESOLVABLE_REFERENCE\n            } else {\n                Array.prototype.push.apply(report.path, refObj.path);\n                report.addError(\"UNRESOLVABLE_REFERENCE\", [refObj.ref]);\n                report.path = report.path.slice(0, -refObj.path.length);\n\n                // pusblish unresolved references out\n                if (isValidExceptReferences) {\n                    schema.__$missingReferences = schema.__$missingReferences || [];\n                    schema.__$missingReferences.push(refObj);\n                }\n            }\n        }\n        // this might create circular references\n        refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n    }\n\n    var isValid = report.isValid();\n    if (isValid) {\n        schema.__$compiled = true;\n    } else {\n        if (schema.id && typeof schema.id === \"string\") {\n            // remove this schema from schemaCache because it failed to compile\n            SchemaCache.removeFromCacheByUri.call(this, schema.id);\n        }\n    }\n\n    // we don't need the root pointer anymore\n    if (isRoot) {\n        report.rootSchema = undefined;\n    }\n\n    return isValid;\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1NjaGVtYUNvbXBpbGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFVO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFlO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLDJEQUFTOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSGFyeXU1NDEyXFxEZXNrdG9wXFxTY2hvb2xcXGNhcHN0b25lXFxwaWNzZWxcXGJhY2tlbmRcXG5vZGVfbW9kdWxlc1xcei1zY2hlbWFcXHNyY1xcU2NoZW1hQ29tcGlsYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZXBvcnQgICAgICA9IHJlcXVpcmUoXCIuL1JlcG9ydFwiKTtcbnZhciBTY2hlbWFDYWNoZSA9IHJlcXVpcmUoXCIuL1NjaGVtYUNhY2hlXCIpO1xudmFyIFV0aWxzICAgICAgID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG5cbmZ1bmN0aW9uIG1lcmdlUmVmZXJlbmNlKHNjb3BlLCByZWYpIHtcbiAgICBpZiAoVXRpbHMuaXNBYnNvbHV0ZVVyaShyZWYpKSB7XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZFNjb3BlID0gc2NvcGUuam9pbihcIlwiKSxcbiAgICAgICAgaXNTY29wZUFic29sdXRlID0gVXRpbHMuaXNBYnNvbHV0ZVVyaShqb2luZWRTY29wZSksXG4gICAgICAgIGlzU2NvcGVSZWxhdGl2ZSA9IFV0aWxzLmlzUmVsYXRpdmVVcmkoam9pbmVkU2NvcGUpLFxuICAgICAgICBpc1JlZlJlbGF0aXZlID0gVXRpbHMuaXNSZWxhdGl2ZVVyaShyZWYpLFxuICAgICAgICB0b1JlbW92ZTtcblxuICAgIGlmIChpc1Njb3BlQWJzb2x1dGUgJiYgaXNSZWZSZWxhdGl2ZSkge1xuICAgICAgICB0b1JlbW92ZSA9IGpvaW5lZFNjb3BlLm1hdGNoKC9cXC9bXlxcL10qJC8pO1xuICAgICAgICBpZiAodG9SZW1vdmUpIHtcbiAgICAgICAgICAgIGpvaW5lZFNjb3BlID0gam9pbmVkU2NvcGUuc2xpY2UoMCwgdG9SZW1vdmUuaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTY29wZVJlbGF0aXZlICYmIGlzUmVmUmVsYXRpdmUpIHtcbiAgICAgICAgam9pbmVkU2NvcGUgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUmVtb3ZlID0gam9pbmVkU2NvcGUubWF0Y2goL1teIy9dKyQvKTtcbiAgICAgICAgaWYgKHRvUmVtb3ZlKSB7XG4gICAgICAgICAgICBqb2luZWRTY29wZSA9IGpvaW5lZFNjb3BlLnNsaWNlKDAsIHRvUmVtb3ZlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXMgPSBqb2luZWRTY29wZSArIHJlZjtcbiAgICByZXMgPSByZXMucmVwbGFjZSgvIyMvLCBcIiNcIik7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29sbGVjdFJlZmVyZW5jZXMob2JqLCByZXN1bHRzLCBzY29wZSwgcGF0aCkge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICAgIHNjb3BlID0gc2NvcGUgfHwgW107XG4gICAgcGF0aCA9IHBhdGggfHwgW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmouaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2NvcGUucHVzaChvYmouaWQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqLiRyZWYgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iai5fXyRyZWZSZXNvbHZlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgcmVmOiBtZXJnZVJlZmVyZW5jZShzY29wZSwgb2JqLiRyZWYpLFxuICAgICAgICAgICAga2V5OiBcIiRyZWZcIixcbiAgICAgICAgICAgIG9iajogb2JqLFxuICAgICAgICAgICAgcGF0aDogcGF0aC5zbGljZSgwKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmouJHNjaGVtYSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqLl9fJHNjaGVtYVJlc29sdmVkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICByZWY6IG1lcmdlUmVmZXJlbmNlKHNjb3BlLCBvYmouJHNjaGVtYSksXG4gICAgICAgICAgICBrZXk6IFwiJHNjaGVtYVwiLFxuICAgICAgICAgICAgb2JqOiBvYmosXG4gICAgICAgICAgICBwYXRoOiBwYXRoLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpZHg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZHggPSBvYmoubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChpZHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBjb2xsZWN0UmVmZXJlbmNlcyhvYmpbaWR4XSwgcmVzdWx0cywgc2NvcGUsIHBhdGgpO1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgaWR4ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgLy8gZG8gbm90IHJlY3Vyc2UgdGhyb3VnaCByZXNvbHZlZCByZWZlcmVuY2VzIGFuZCBvdGhlciB6LXNjaGVtYSBwcm9wc1xuICAgICAgICAgICAgaWYgKGtleXNbaWR4XS5pbmRleE9mKFwiX18kXCIpID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBwYXRoLnB1c2goa2V5c1tpZHhdKTtcbiAgICAgICAgICAgIGNvbGxlY3RSZWZlcmVuY2VzKG9ialtrZXlzW2lkeF1dLCByZXN1bHRzLCBzY29wZSwgcGF0aCk7XG4gICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmouaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2NvcGUucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbnZhciBjb21waWxlQXJyYXlPZlNjaGVtYXNMb29wID0gZnVuY3Rpb24gKG1haW5SZXBvcnQsIGFycikge1xuICAgIHZhciBpZHggPSBhcnIubGVuZ3RoLFxuICAgICAgICBjb21waWxlZENvdW50ID0gMDtcblxuICAgIHdoaWxlIChpZHgtLSkge1xuXG4gICAgICAgIC8vIHRyeSB0byBjb21waWxlIGVhY2ggc2NoZW1hIHNlcGFyYXRlbHlcbiAgICAgICAgdmFyIHJlcG9ydCA9IG5ldyBSZXBvcnQobWFpblJlcG9ydCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gZXhwb3J0cy5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCBhcnJbaWR4XSk7XG4gICAgICAgIGlmIChpc1ZhbGlkKSB7IGNvbXBpbGVkQ291bnQrKzsgfVxuXG4gICAgICAgIC8vIGNvcHkgZXJyb3JzIHRvIHJlcG9ydFxuICAgICAgICBtYWluUmVwb3J0LmVycm9ycyA9IG1haW5SZXBvcnQuZXJyb3JzLmNvbmNhdChyZXBvcnQuZXJyb3JzKTtcblxuICAgIH1cblxuICAgIHJldHVybiBjb21waWxlZENvdW50O1xufTtcblxuZnVuY3Rpb24gZmluZElkKGFyciwgaWQpIHtcbiAgICB2YXIgaWR4ID0gYXJyLmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgaWYgKGFycltpZHhdLmlkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycltpZHhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgY29tcGlsZUFycmF5T2ZTY2hlbWFzID0gZnVuY3Rpb24gKHJlcG9ydCwgYXJyKSB7XG5cbiAgICB2YXIgY29tcGlsZWQgPSAwLFxuICAgICAgICBsYXN0TG9vcENvbXBpbGVkO1xuXG4gICAgZG8ge1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgVU5SRVNPTFZBQkxFX1JFRkVSRU5DRSBlcnJvcnMgYmVmb3JlIGNvbXBpbGluZyBhcnJheSBhZ2FpblxuICAgICAgICB2YXIgaWR4ID0gcmVwb3J0LmVycm9ycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgaWYgKHJlcG9ydC5lcnJvcnNbaWR4XS5jb2RlID09PSBcIlVOUkVTT0xWQUJMRV9SRUZFUkVOQ0VcIikge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5lcnJvcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1lbWJlciBob3cgbWFueSB3ZXJlIGNvbXBpbGVkIGluIHRoZSBsYXN0IGxvb3BcbiAgICAgICAgbGFzdExvb3BDb21waWxlZCA9IGNvbXBpbGVkO1xuXG4gICAgICAgIC8vIGNvdW50IGhvdyBtYW55IGFyZSBjb21waWxlZCBub3dcbiAgICAgICAgY29tcGlsZWQgPSBjb21waWxlQXJyYXlPZlNjaGVtYXNMb29wLmNhbGwodGhpcywgcmVwb3J0LCBhcnIpO1xuXG4gICAgICAgIC8vIGZpeCBfXyRtaXNzaW5nUmVmZXJlbmNlcyBpZiBwb3NzaWJsZVxuICAgICAgICBpZHggPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIHZhciBzY2ggPSBhcnJbaWR4XTtcbiAgICAgICAgICAgIGlmIChzY2guX18kbWlzc2luZ1JlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4MiA9IHNjaC5fXyRtaXNzaW5nUmVmZXJlbmNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlkeDItLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmT2JqID0gc2NoLl9fJG1pc3NpbmdSZWZlcmVuY2VzW2lkeDJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBmaW5kSWQoYXJyLCByZWZPYmoucmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGNyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZPYmoub2JqW1wiX19cIiArIHJlZk9iai5rZXkgKyBcIlJlc29sdmVkXCJdID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHJlc29sdmVkIG5vdyBzbyBkZWxldGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaC5fXyRtaXNzaW5nUmVmZXJlbmNlcy5zcGxpY2UoaWR4MiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5fXyRtaXNzaW5nUmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaC5fXyRtaXNzaW5nUmVmZXJlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBrZWVwIHJlcGVhdGluZyBpZiBub3QgYWxsIGNvbXBpbGVkIGFuZCBhdCBsZWFzdCBvbmUgbW9yZSB3YXMgY29tcGlsZWQgaW4gdGhlIGxhc3QgbG9vcFxuICAgIH0gd2hpbGUgKGNvbXBpbGVkICE9PSBhcnIubGVuZ3RoICYmIGNvbXBpbGVkICE9PSBsYXN0TG9vcENvbXBpbGVkKTtcblxuICAgIHJldHVybiByZXBvcnQuaXNWYWxpZCgpO1xuXG59O1xuXG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcblxuICAgIHJlcG9ydC5jb21tb25FcnJvck1lc3NhZ2UgPSBcIlNDSEVNQV9DT01QSUxBVElPTl9GQUlMRURcIjtcblxuICAgIC8vIGlmIHNjaGVtYSBpcyBhIHN0cmluZywgYXNzdW1lIGl0J3MgYSB1cmlcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbG9hZGVkU2NoZW1hID0gU2NoZW1hQ2FjaGUuZ2V0U2NoZW1hQnlVcmkuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSk7XG4gICAgICAgIGlmICghbG9hZGVkU2NoZW1hKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJTQ0hFTUFfTk9UX1JFQUNIQUJMRVwiLCBbc2NoZW1hXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2NoZW1hID0gbG9hZGVkU2NoZW1hO1xuICAgIH1cblxuICAgIC8vIGlmIHNjaGVtYSBpcyBhbiBhcnJheSwgYXNzdW1lIGl0J3MgYW4gYXJyYXkgb2Ygc2NoZW1hc1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVBcnJheU9mU2NoZW1hcy5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFuIGlkIHRoYW4gaXQgc2hvdWxkIGJlIGNhY2hlZCBhbHJlYWR5IChpZiB0aGlzIGluc3RhbmNlIGhhcyBjb21waWxlZCBpdClcbiAgICBpZiAoc2NoZW1hLl9fJGNvbXBpbGVkICYmIHNjaGVtYS5pZCAmJiBTY2hlbWFDYWNoZS5jaGVja0NhY2hlRm9yVXJpLmNhbGwodGhpcywgc2NoZW1hLmlkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2NoZW1hLl9fJGNvbXBpbGVkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCByZS1jb21waWxlIHNjaGVtYXNcbiAgICBpZiAoc2NoZW1hLl9fJGNvbXBpbGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuaWQgJiYgdHlwZW9mIHNjaGVtYS5pZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBhZGQgdGhpcyB0byBvdXIgc2NoZW1hQ2FjaGUgKGJlZm9yZSBjb21waWxhdGlvbiBpbiBjYXNlIHdlIGhhdmUgcmVmZXJlbmNlcyBpbmNsdWRpbmcgaWQpXG4gICAgICAgIFNjaGVtYUNhY2hlLmNhY2hlU2NoZW1hQnlVcmkuY2FsbCh0aGlzLCBzY2hlbWEuaWQsIHNjaGVtYSk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCByZWN1cnNpdmVseSwgc28gd2UgbmVlZCB0byByZW1lbWJlciBvdXIgcm9vdFxuICAgIHZhciBpc1Jvb3QgPSBmYWxzZTtcbiAgICBpZiAoIXJlcG9ydC5yb290U2NoZW1hKSB7XG4gICAgICAgIHJlcG9ydC5yb290U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBpc1Jvb3QgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBhbGwgX18kbWlzc2luZ1JlZmVyZW5jZXMgZnJvbSBwcmV2aW91cyBjb21waWxhdGlvbiBhdHRlbXB0c1xuICAgIHZhciBpc1ZhbGlkRXhjZXB0UmVmZXJlbmNlcyA9IHJlcG9ydC5pc1ZhbGlkKCk7XG4gICAgZGVsZXRlIHNjaGVtYS5fXyRtaXNzaW5nUmVmZXJlbmNlcztcblxuICAgIC8vIGNvbGxlY3QgYWxsIHJlZmVyZW5jZXMgdGhhdCBuZWVkIHRvIGJlIHJlc29sdmVkIC0gJHJlZiBhbmQgJHNjaGVtYVxuICAgIHZhciByZWZzID0gY29sbGVjdFJlZmVyZW5jZXMuY2FsbCh0aGlzLCBzY2hlbWEpLFxuICAgICAgICBpZHggPSByZWZzLmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgdGhlIGNvbGxlY3RlZCByZWZlcmVuY2VzIGludG8gX194eHhSZXNvbHZlZCBwb2ludGVyXG4gICAgICAgIHZhciByZWZPYmogPSByZWZzW2lkeF07XG4gICAgICAgIHZhciByZXNwb25zZSA9IFNjaGVtYUNhY2hlLmdldFNjaGVtYUJ5VXJpLmNhbGwodGhpcywgcmVwb3J0LCByZWZPYmoucmVmLCBzY2hlbWEpO1xuXG4gICAgICAgIC8vIHdlIGNhbiB0cnkgdG8gdXNlIGN1c3RvbSBzY2hlbWFSZWFkZXIgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFSZWFkZXIgPSB0aGlzLmdldFNjaGVtYVJlYWRlcigpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIGl0J3Mgc3VwcG9zZWQgdG8gcmV0dXJuIGEgdmFsaWQgc2NoZW1hXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzY2hlbWFSZWFkZXIocmVmT2JqLnJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgbmVlZHMgdG8gaGF2ZSB0aGUgaWRcbiAgICAgICAgICAgICAgICAgICAgcy5pZCA9IHJlZk9iai5yZWY7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBjb21waWxlIHRoZSBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnJlcG9ydCA9IG5ldyBSZXBvcnQocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHBvcnRzLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzdWJyZXBvcnQsIHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGVycm9ycyB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5lcnJvcnMgPSByZXBvcnQuZXJyb3JzLmNvbmNhdChzdWJyZXBvcnQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gU2NoZW1hQ2FjaGUuZ2V0U2NoZW1hQnlVcmkuY2FsbCh0aGlzLCByZXBvcnQsIHJlZk9iai5yZWYsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgIHZhciBoYXNOb3RWYWxpZCA9IHJlcG9ydC5oYXNFcnJvcihcIlJFTU9URV9OT1RfVkFMSURcIiwgW3JlZk9iai5yZWZdKTtcbiAgICAgICAgICAgIHZhciBpc0Fic29sdXRlID0gVXRpbHMuaXNBYnNvbHV0ZVVyaShyZWZPYmoucmVmKTtcbiAgICAgICAgICAgIHZhciBpc0Rvd25sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVVbnJlc29sdmFibGVSZW1vdGVzID0gdGhpcy5vcHRpb25zLmlnbm9yZVVucmVzb2x2YWJsZVJlZmVyZW5jZXMgPT09IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IGFkZCBVTlJFU09MVkFCTEVfUkVGRVJFTkNFIGZvciBzY2hlbWFzIHdlIGFscmVhZHkgaGF2ZSBkb3dubG9hZGVkXG4gICAgICAgICAgICAgICAgLy8gYW5kIHNldCB0aHJvdWdoIHNldFJlbW90ZVJlZmVyZW5jZSBtZXRob2RcbiAgICAgICAgICAgICAgICBpc0Rvd25sb2FkZWQgPSBTY2hlbWFDYWNoZS5jaGVja0NhY2hlRm9yVXJpLmNhbGwodGhpcywgcmVmT2JqLnJlZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNOb3RWYWxpZCkge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaGFzIFJFTU9URV9OT1RfVkFMSUQgZXJyb3IgZm9yIHRoaXMgb25lXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlnbm9yZVVucmVzb2x2YWJsZVJlbW90ZXMgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVVucmVzb2x2YWJsZVJlbW90ZXMgaXMgb24gYW5kIHJlbW90ZSBpc0Fic29sdXRlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRG93bmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW90ZSBpcyBkb3dubG9hZGVkLCBzbyBubyBVTlJFU09MVkFCTEVfUkVGRVJFTkNFXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlcG9ydC5wYXRoLCByZWZPYmoucGF0aCk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiVU5SRVNPTFZBQkxFX1JFRkVSRU5DRVwiLCBbcmVmT2JqLnJlZl0pO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoID0gcmVwb3J0LnBhdGguc2xpY2UoMCwgLXJlZk9iai5wYXRoLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwdXNibGlzaCB1bnJlc29sdmVkIHJlZmVyZW5jZXMgb3V0XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRFeGNlcHRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYS5fXyRtaXNzaW5nUmVmZXJlbmNlcyA9IHNjaGVtYS5fXyRtaXNzaW5nUmVmZXJlbmNlcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLl9fJG1pc3NpbmdSZWZlcmVuY2VzLnB1c2gocmVmT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtaWdodCBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICByZWZPYmoub2JqW1wiX19cIiArIHJlZk9iai5rZXkgKyBcIlJlc29sdmVkXCJdID0gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgdmFyIGlzVmFsaWQgPSByZXBvcnQuaXNWYWxpZCgpO1xuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgIHNjaGVtYS5fXyRjb21waWxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNjaGVtYS5pZCAmJiB0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBzY2hlbWEgZnJvbSBzY2hlbWFDYWNoZSBiZWNhdXNlIGl0IGZhaWxlZCB0byBjb21waWxlXG4gICAgICAgICAgICBTY2hlbWFDYWNoZS5yZW1vdmVGcm9tQ2FjaGVCeVVyaS5jYWxsKHRoaXMsIHNjaGVtYS5pZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRoZSByb290IHBvaW50ZXIgYW55bW9yZVxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVwb3J0LnJvb3RTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQ7XG5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/SchemaCompilation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/SchemaValidation.js":
/*!*******************************************************!*\
  !*** ./node_modules/z-schema/src/SchemaValidation.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FormatValidators = __webpack_require__(/*! ./FormatValidators */ \"(rsc)/./node_modules/z-schema/src/FormatValidators.js\"),\n    JsonValidation   = __webpack_require__(/*! ./JsonValidation */ \"(rsc)/./node_modules/z-schema/src/JsonValidation.js\"),\n    Report           = __webpack_require__(/*! ./Report */ \"(rsc)/./node_modules/z-schema/src/Report.js\"),\n    Utils            = __webpack_require__(/*! ./Utils */ \"(rsc)/./node_modules/z-schema/src/Utils.js\");\n\nvar SchemaValidators = {\n    $ref: function (report, schema) {\n        // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07\n        // http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03\n        if (typeof schema.$ref !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"$ref\", \"string\"]);\n        }\n    },\n    $schema: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-core.html#rfc.section.6\n        if (typeof schema.$schema !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"$schema\", \"string\"]);\n        }\n    },\n    multipleOf: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.1\n        if (typeof schema.multipleOf !== \"number\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"multipleOf\", \"number\"]);\n        } else if (schema.multipleOf <= 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"multipleOf\", \"strictly greater than 0\"]);\n        }\n    },\n    maximum: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1\n        if (typeof schema.maximum !== \"number\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"maximum\", \"number\"]);\n        }\n    },\n    exclusiveMaximum: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1\n        if (typeof schema.exclusiveMaximum !== \"boolean\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"exclusiveMaximum\", \"boolean\"]);\n        } else if (schema.maximum === undefined) {\n            report.addError(\"KEYWORD_DEPENDENCY\", [\"exclusiveMaximum\", \"maximum\"]);\n        }\n    },\n    minimum: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1\n        if (typeof schema.minimum !== \"number\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"minimum\", \"number\"]);\n        }\n    },\n    exclusiveMinimum: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1\n        if (typeof schema.exclusiveMinimum !== \"boolean\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"exclusiveMinimum\", \"boolean\"]);\n        } else if (schema.minimum === undefined) {\n            report.addError(\"KEYWORD_DEPENDENCY\", [\"exclusiveMinimum\", \"minimum\"]);\n        }\n    },\n    maxLength: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.1\n        if (Utils.whatIs(schema.maxLength) !== \"integer\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"maxLength\", \"integer\"]);\n        } else if (schema.maxLength < 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"maxLength\", \"greater than, or equal to 0\"]);\n        }\n    },\n    minLength: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.1\n        if (Utils.whatIs(schema.minLength) !== \"integer\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"minLength\", \"integer\"]);\n        } else if (schema.minLength < 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"minLength\", \"greater than, or equal to 0\"]);\n        }\n    },\n    pattern: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.1\n        if (typeof schema.pattern !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"pattern\", \"string\"]);\n        } else {\n            try {\n                RegExp(schema.pattern);\n            } catch (e) {\n                report.addError(\"KEYWORD_PATTERN\", [\"pattern\", schema.pattern]);\n            }\n        }\n    },\n    additionalItems: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1\n        var type = Utils.whatIs(schema.additionalItems);\n        if (type !== \"boolean\" && type !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"additionalItems\", [\"boolean\", \"object\"]]);\n        } else if (type === \"object\") {\n            report.path.push(\"additionalItems\");\n            exports.validateSchema.call(this, report, schema.additionalItems);\n            report.path.pop();\n        }\n    },\n    items: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1\n        var type = Utils.whatIs(schema.items);\n\n        if (type === \"object\") {\n            report.path.push(\"items\");\n            exports.validateSchema.call(this, report, schema.items);\n            report.path.pop();\n        } else if (type === \"array\") {\n            var idx = schema.items.length;\n            while (idx--) {\n                report.path.push(\"items\");\n                report.path.push(idx.toString());\n                exports.validateSchema.call(this, report, schema.items[idx]);\n                report.path.pop();\n                report.path.pop();\n            }\n        } else {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"items\", [\"array\", \"object\"]]);\n        }\n\n        // custom - strict mode\n        if (this.options.forceAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {\n            report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"additionalItems\"]);\n        }\n        // custome - assume defined false mode\n        if (this.options.assumeAdditional && schema.additionalItems === undefined && Array.isArray(schema.items)) {\n            schema.additionalItems = false;\n        }\n    },\n    maxItems: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.1\n        if (typeof schema.maxItems !== \"number\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"maxItems\", \"integer\"]);\n        } else if (schema.maxItems < 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"maxItems\", \"greater than, or equal to 0\"]);\n        }\n    },\n    minItems: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.1\n        if (Utils.whatIs(schema.minItems) !== \"integer\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"minItems\", \"integer\"]);\n        } else if (schema.minItems < 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"minItems\", \"greater than, or equal to 0\"]);\n        }\n    },\n    uniqueItems: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.1\n        if (typeof schema.uniqueItems !== \"boolean\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"uniqueItems\", \"boolean\"]);\n        }\n    },\n    maxProperties: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.1\n        if (Utils.whatIs(schema.maxProperties) !== \"integer\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"maxProperties\", \"integer\"]);\n        } else if (schema.maxProperties < 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"maxProperties\", \"greater than, or equal to 0\"]);\n        }\n    },\n    minProperties: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.1\n        if (Utils.whatIs(schema.minProperties) !== \"integer\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"minProperties\", \"integer\"]);\n        } else if (schema.minProperties < 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"minProperties\", \"greater than, or equal to 0\"]);\n        }\n    },\n    required: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.1\n        if (Utils.whatIs(schema.required) !== \"array\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"required\", \"array\"]);\n        } else if (schema.required.length === 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"required\", \"an array with at least one element\"]);\n        } else {\n            var idx = schema.required.length;\n            while (idx--) {\n                if (typeof schema.required[idx] !== \"string\") {\n                    report.addError(\"KEYWORD_VALUE_TYPE\", [\"required\", \"string\"]);\n                }\n            }\n            if (Utils.isUniqueArray(schema.required) === false) {\n                report.addError(\"KEYWORD_MUST_BE\", [\"required\", \"an array with unique items\"]);\n            }\n        }\n    },\n    additionalProperties: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1\n        var type = Utils.whatIs(schema.additionalProperties);\n        if (type !== \"boolean\" && type !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"additionalProperties\", [\"boolean\", \"object\"]]);\n        } else if (type === \"object\") {\n            report.path.push(\"additionalProperties\");\n            exports.validateSchema.call(this, report, schema.additionalProperties);\n            report.path.pop();\n        }\n    },\n    properties: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1\n        if (Utils.whatIs(schema.properties) !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"properties\", \"object\"]);\n            return;\n        }\n\n        var keys = Object.keys(schema.properties),\n            idx = keys.length;\n        while (idx--) {\n            var key = keys[idx],\n                val = schema.properties[key];\n            report.path.push(\"properties\");\n            report.path.push(key);\n            exports.validateSchema.call(this, report, val);\n            report.path.pop();\n            report.path.pop();\n        }\n\n        // custom - strict mode\n        if (this.options.forceAdditional === true && schema.additionalProperties === undefined) {\n            report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"additionalProperties\"]);\n        }\n        // custome - assume defined false mode\n        if (this.options.assumeAdditional && schema.additionalProperties === undefined) {\n            schema.additionalProperties = false;\n        }\n        // custom - forceProperties\n        if (this.options.forceProperties === true && keys.length === 0) {\n            report.addError(\"CUSTOM_MODE_FORCE_PROPERTIES\", [\"properties\"]);\n        }\n    },\n    patternProperties: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1\n        if (Utils.whatIs(schema.patternProperties) !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"patternProperties\", \"object\"]);\n            return;\n        }\n\n        var keys = Object.keys(schema.patternProperties),\n            idx = keys.length;\n        while (idx--) {\n            var key = keys[idx],\n                val = schema.patternProperties[key];\n            try {\n                RegExp(key);\n            } catch (e) {\n                report.addError(\"KEYWORD_PATTERN\", [\"patternProperties\", key]);\n            }\n            report.path.push(\"patternProperties\");\n            report.path.push(key.toString());\n            exports.validateSchema.call(this, report, val);\n            report.path.pop();\n            report.path.pop();\n        }\n\n        // custom - forceProperties\n        if (this.options.forceProperties === true && keys.length === 0) {\n            report.addError(\"CUSTOM_MODE_FORCE_PROPERTIES\", [\"patternProperties\"]);\n        }\n    },\n    dependencies: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.1\n        if (Utils.whatIs(schema.dependencies) !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"dependencies\", \"object\"]);\n        } else {\n            var keys = Object.keys(schema.dependencies),\n                idx = keys.length;\n            while (idx--) {\n                var schemaKey = keys[idx],\n                    schemaDependency = schema.dependencies[schemaKey],\n                    type = Utils.whatIs(schemaDependency);\n\n                if (type === \"object\") {\n                    report.path.push(\"dependencies\");\n                    report.path.push(schemaKey);\n                    exports.validateSchema.call(this, report, schemaDependency);\n                    report.path.pop();\n                    report.path.pop();\n                } else if (type === \"array\") {\n                    var idx2 = schemaDependency.length;\n                    if (idx2 === 0) {\n                        report.addError(\"KEYWORD_MUST_BE\", [\"dependencies\", \"not empty array\"]);\n                    }\n                    while (idx2--) {\n                        if (typeof schemaDependency[idx2] !== \"string\") {\n                            report.addError(\"KEYWORD_VALUE_TYPE\", [\"dependensices\", \"string\"]);\n                        }\n                    }\n                    if (Utils.isUniqueArray(schemaDependency) === false) {\n                        report.addError(\"KEYWORD_MUST_BE\", [\"dependencies\", \"an array with unique items\"]);\n                    }\n                } else {\n                    report.addError(\"KEYWORD_VALUE_TYPE\", [\"dependencies\", \"object or array\"]);\n                }\n            }\n        }\n    },\n    enum: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.1\n        if (Array.isArray(schema.enum) === false) {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"enum\", \"array\"]);\n        } else if (schema.enum.length === 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"enum\", \"an array with at least one element\"]);\n        } else if (Utils.isUniqueArray(schema.enum) === false) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"enum\", \"an array with unique elements\"]);\n        }\n    },\n    type: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.1\n        var primitiveTypes = [\"array\", \"boolean\", \"integer\", \"number\", \"null\", \"object\", \"string\"],\n            primitiveTypeStr = primitiveTypes.join(\",\"),\n            isArray = Array.isArray(schema.type);\n\n        if (isArray) {\n            var idx = schema.type.length;\n            while (idx--) {\n                if (primitiveTypes.indexOf(schema.type[idx]) === -1) {\n                    report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"type\", primitiveTypeStr]);\n                }\n            }\n            if (Utils.isUniqueArray(schema.type) === false) {\n                report.addError(\"KEYWORD_MUST_BE\", [\"type\", \"an object with unique properties\"]);\n            }\n        } else if (typeof schema.type === \"string\") {\n            if (primitiveTypes.indexOf(schema.type) === -1) {\n                report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"type\", primitiveTypeStr]);\n            }\n        } else {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"type\", [\"string\", \"array\"]]);\n        }\n\n        if (this.options.noEmptyStrings === true) {\n            if (schema.type === \"string\" || isArray && schema.type.indexOf(\"string\") !== -1) {\n                if (schema.minLength === undefined &&\n                    schema.enum === undefined &&\n                    schema.format === undefined) {\n\n                    schema.minLength = 1;\n                }\n            }\n        }\n        if (this.options.noEmptyArrays === true) {\n            if (schema.type === \"array\" || isArray && schema.type.indexOf(\"array\") !== -1) {\n                if (schema.minItems === undefined) {\n                    schema.minItems = 1;\n                }\n            }\n        }\n        if (this.options.forceProperties === true) {\n            if (schema.type === \"object\" || isArray && schema.type.indexOf(\"object\") !== -1) {\n                if (schema.properties === undefined && schema.patternProperties === undefined) {\n                    report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"properties\"]);\n                }\n            }\n        }\n        if (this.options.forceItems === true) {\n            if (schema.type === \"array\" || isArray && schema.type.indexOf(\"array\") !== -1) {\n                if (schema.items === undefined) {\n                    report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"items\"]);\n                }\n            }\n        }\n        if (this.options.forceMinItems === true) {\n            if (schema.type === \"array\" || isArray && schema.type.indexOf(\"array\") !== -1) {\n                if (schema.minItems === undefined) {\n                    report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"minItems\"]);\n                }\n            }\n        }\n        if (this.options.forceMaxItems === true) {\n            if (schema.type === \"array\" || isArray && schema.type.indexOf(\"array\") !== -1) {\n                if (schema.maxItems === undefined) {\n                    report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"maxItems\"]);\n                }\n            }\n        }\n        if (this.options.forceMinLength === true) {\n            if (schema.type === \"string\" || isArray && schema.type.indexOf(\"string\") !== -1) {\n                if (schema.minLength === undefined &&\n                    schema.format === undefined &&\n                    schema.enum === undefined &&\n                    schema.pattern === undefined) {\n                    report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"minLength\"]);\n                }\n            }\n        }\n        if (this.options.forceMaxLength === true) {\n            if (schema.type === \"string\" || isArray && schema.type.indexOf(\"string\") !== -1) {\n                if (schema.maxLength === undefined &&\n                    schema.format === undefined &&\n                    schema.enum === undefined &&\n                    schema.pattern === undefined) {\n                    report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"maxLength\"]);\n                }\n            }\n        }\n    },\n    allOf: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.1\n        if (Array.isArray(schema.allOf) === false) {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"allOf\", \"array\"]);\n        } else if (schema.allOf.length === 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"allOf\", \"an array with at least one element\"]);\n        } else {\n            var idx = schema.allOf.length;\n            while (idx--) {\n                report.path.push(\"allOf\");\n                report.path.push(idx.toString());\n                exports.validateSchema.call(this, report, schema.allOf[idx]);\n                report.path.pop();\n                report.path.pop();\n            }\n        }\n    },\n    anyOf: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.1\n        if (Array.isArray(schema.anyOf) === false) {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"anyOf\", \"array\"]);\n        } else if (schema.anyOf.length === 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"anyOf\", \"an array with at least one element\"]);\n        } else {\n            var idx = schema.anyOf.length;\n            while (idx--) {\n                report.path.push(\"anyOf\");\n                report.path.push(idx.toString());\n                exports.validateSchema.call(this, report, schema.anyOf[idx]);\n                report.path.pop();\n                report.path.pop();\n            }\n        }\n    },\n    oneOf: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.1\n        if (Array.isArray(schema.oneOf) === false) {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"oneOf\", \"array\"]);\n        } else if (schema.oneOf.length === 0) {\n            report.addError(\"KEYWORD_MUST_BE\", [\"oneOf\", \"an array with at least one element\"]);\n        } else {\n            var idx = schema.oneOf.length;\n            while (idx--) {\n                report.path.push(\"oneOf\");\n                report.path.push(idx.toString());\n                exports.validateSchema.call(this, report, schema.oneOf[idx]);\n                report.path.pop();\n                report.path.pop();\n            }\n        }\n    },\n    not: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.1\n        if (Utils.whatIs(schema.not) !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"not\", \"object\"]);\n        } else {\n            report.path.push(\"not\");\n            exports.validateSchema.call(this, report, schema.not);\n            report.path.pop();\n        }\n    },\n    definitions: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.1\n        if (Utils.whatIs(schema.definitions) !== \"object\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"definitions\", \"object\"]);\n        } else {\n            var keys = Object.keys(schema.definitions),\n                idx = keys.length;\n            while (idx--) {\n                var key = keys[idx],\n                    val = schema.definitions[key];\n                report.path.push(\"definitions\");\n                report.path.push(key);\n                exports.validateSchema.call(this, report, val);\n                report.path.pop();\n                report.path.pop();\n            }\n        }\n    },\n    format: function (report, schema) {\n        if (typeof schema.format !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"format\", \"string\"]);\n        } else {\n            if (FormatValidators[schema.format] === undefined && this.options.ignoreUnknownFormats !== true) {\n                report.addError(\"UNKNOWN_FORMAT\", [schema.format]);\n            }\n        }\n    },\n    id: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-core.html#rfc.section.7.2\n        if (typeof schema.id !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"id\", \"string\"]);\n        }\n    },\n    title: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1\n        if (typeof schema.title !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"title\", \"string\"]);\n        }\n    },\n    description: function (report, schema) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1\n        if (typeof schema.description !== \"string\") {\n            report.addError(\"KEYWORD_TYPE_EXPECTED\", [\"description\", \"string\"]);\n        }\n    },\n    \"default\": function (/* report, schema */) {\n        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.2\n        // There are no restrictions placed on the value of this keyword.\n    }\n};\n\n/**\n *\n * @param {Report} report\n * @param {*[]} arr\n *\n * @returns {boolean}\n */\nvar validateArrayOfSchemas = function (report, arr) {\n    var idx = arr.length;\n    while (idx--) {\n        exports.validateSchema.call(this, report, arr[idx]);\n    }\n    return report.isValid();\n};\n\n/**\n *\n * @param {Report} report\n * @param {*} schema\n */\nexports.validateSchema = function (report, schema) {\n\n    report.commonErrorMessage = \"SCHEMA_VALIDATION_FAILED\";\n\n    // if schema is an array, assume it's an array of schemas\n    if (Array.isArray(schema)) {\n        return validateArrayOfSchemas.call(this, report, schema);\n    }\n\n    // do not revalidate schema that has already been validated once\n    if (schema.__$validated) {\n        return true;\n    }\n\n    // if $schema is present, this schema should validate against that $schema\n    var hasParentSchema = schema.$schema && schema.id !== schema.$schema;\n    if (hasParentSchema) {\n        if (schema.__$schemaResolved && schema.__$schemaResolved !== schema) {\n            var subReport = new Report(report);\n            var valid = JsonValidation.validate.call(this, subReport, schema.__$schemaResolved, schema);\n            if (valid === false) {\n                report.addError(\"PARENT_SCHEMA_VALIDATION_FAILED\", null, subReport);\n            }\n        } else {\n            if (this.options.ignoreUnresolvableReferences !== true) {\n                report.addError(\"REF_UNRESOLVED\", [schema.$schema]);\n            }\n        }\n    }\n\n    if (this.options.noTypeless === true) {\n        // issue #36 - inherit type to anyOf, oneOf, allOf if noTypeless is defined\n        if (schema.type !== undefined) {\n            var schemas = [];\n            if (Array.isArray(schema.anyOf)) { schemas = schemas.concat(schema.anyOf); }\n            if (Array.isArray(schema.oneOf)) { schemas = schemas.concat(schema.oneOf); }\n            if (Array.isArray(schema.allOf)) { schemas = schemas.concat(schema.allOf); }\n            schemas.forEach(function (sch) {\n                if (!sch.type) { sch.type = schema.type; }\n            });\n        }\n        // end issue #36\n        if (schema.enum === undefined &&\n            schema.type === undefined &&\n            schema.anyOf === undefined &&\n            schema.oneOf === undefined &&\n            schema.not === undefined &&\n            schema.$ref === undefined) {\n            report.addError(\"KEYWORD_UNDEFINED_STRICT\", [\"type\"]);\n        }\n    }\n\n    var keys = Object.keys(schema),\n        idx = keys.length;\n    while (idx--) {\n        var key = keys[idx];\n        if (key.indexOf(\"__\") === 0) { continue; }\n        if (SchemaValidators[key] !== undefined) {\n            SchemaValidators[key].call(this, report, schema);\n        } else if (!hasParentSchema) {\n            if (this.options.noExtraKeywords === true) {\n                report.addError(\"KEYWORD_UNEXPECTED\", [key]);\n            }\n        }\n    }\n\n    if (this.options.pedanticCheck === true) {\n        if (schema.enum) {\n            // break recursion\n            var tmpSchema = Utils.clone(schema);\n            delete tmpSchema.enum;\n            delete tmpSchema.default;\n\n            report.path.push(\"enum\");\n            idx = schema.enum.length;\n            while (idx--) {\n                report.path.push(idx.toString());\n                JsonValidation.validate.call(this, report, tmpSchema, schema.enum[idx]);\n                report.path.pop();\n            }\n            report.path.pop();\n        }\n\n        if (schema.default) {\n            report.path.push(\"default\");\n            JsonValidation.validate.call(this, report, schema, schema.default);\n            report.path.pop();\n        }\n    }\n\n    var isValid = report.isValid();\n    if (isValid) {\n        schema.__$validated = true;\n    }\n    return isValid;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1NjaGVtYVZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsaUZBQW9CO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLDZFQUFrQjtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQyw2REFBVTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQywyREFBUzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxzQkFBc0I7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0M7QUFDQSxpQ0FBaUM7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFx6LXNjaGVtYVxcc3JjXFxTY2hlbWFWYWxpZGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgRm9ybWF0VmFsaWRhdG9ycyA9IHJlcXVpcmUoXCIuL0Zvcm1hdFZhbGlkYXRvcnNcIiksXG4gICAgSnNvblZhbGlkYXRpb24gICA9IHJlcXVpcmUoXCIuL0pzb25WYWxpZGF0aW9uXCIpLFxuICAgIFJlcG9ydCAgICAgICAgICAgPSByZXF1aXJlKFwiLi9SZXBvcnRcIiksXG4gICAgVXRpbHMgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuXG52YXIgU2NoZW1hVmFsaWRhdG9ycyA9IHtcbiAgICAkcmVmOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1hcHBzYXdnLWpzb24tcG9pbnRlci0wN1xuICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYnJ5YW4tenlwLWpzb24tcmVmLTAzXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLiRyZWYgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCIkcmVmXCIsIFwic3RyaW5nXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJHNjaGVtYTogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLWNvcmUuaHRtbCNyZmMuc2VjdGlvbi42XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLiRzY2hlbWEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCIkc2NoZW1hXCIsIFwic3RyaW5nXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbXVsdGlwbGVPZjogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjEuMS4xXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm11bHRpcGxlT2YgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJtdWx0aXBsZU9mXCIsIFwibnVtYmVyXCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEubXVsdGlwbGVPZiA8PSAwKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX01VU1RfQkVcIiwgW1wibXVsdGlwbGVPZlwiLCBcInN0cmljdGx5IGdyZWF0ZXIgdGhhbiAwXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWF4aW11bTogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjEuMi4xXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heGltdW0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJtYXhpbXVtXCIsIFwibnVtYmVyXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjEuMi4xXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wiZXhjbHVzaXZlTWF4aW11bVwiLCBcImJvb2xlYW5cIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5tYXhpbXVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfREVQRU5ERU5DWVwiLCBbXCJleGNsdXNpdmVNYXhpbXVtXCIsIFwibWF4aW11bVwiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pbmltdW06IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4xLjMuMVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5pbXVtICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wibWluaW11bVwiLCBcIm51bWJlclwiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4xLjMuMVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcImV4Y2x1c2l2ZU1pbmltdW1cIiwgXCJib29sZWFuXCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEubWluaW11bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX0RFUEVOREVOQ1lcIiwgW1wiZXhjbHVzaXZlTWluaW11bVwiLCBcIm1pbmltdW1cIl0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXhMZW5ndGg6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4yLjEuMVxuICAgICAgICBpZiAoVXRpbHMud2hhdElzKHNjaGVtYS5tYXhMZW5ndGgpICE9PSBcImludGVnZXJcIikge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcIm1heExlbmd0aFwiLCBcImludGVnZXJcIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5tYXhMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX01VU1RfQkVcIiwgW1wibWF4TGVuZ3RoXCIsIFwiZ3JlYXRlciB0aGFuLCBvciBlcXVhbCB0byAwXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWluTGVuZ3RoOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMi4yLjFcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhzY2hlbWEubWluTGVuZ3RoKSAhPT0gXCJpbnRlZ2VyXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJtaW5MZW5ndGhcIiwgXCJpbnRlZ2VyXCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEubWluTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcIm1pbkxlbmd0aFwiLCBcImdyZWF0ZXIgdGhhbiwgb3IgZXF1YWwgdG8gMFwiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhdHRlcm46IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4yLjMuMVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5wYXR0ZXJuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wicGF0dGVyblwiLCBcInN0cmluZ1wiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFJlZ0V4cChzY2hlbWEucGF0dGVybik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9QQVRURVJOXCIsIFtcInBhdHRlcm5cIiwgc2NoZW1hLnBhdHRlcm5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbEl0ZW1zOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMy4xLjFcbiAgICAgICAgdmFyIHR5cGUgPSBVdGlscy53aGF0SXMoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG4gICAgICAgIGlmICh0eXBlICE9PSBcImJvb2xlYW5cIiAmJiB0eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wiYWRkaXRpb25hbEl0ZW1zXCIsIFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl1dKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKFwiYWRkaXRpb25hbEl0ZW1zXCIpO1xuICAgICAgICAgICAgZXhwb3J0cy52YWxpZGF0ZVNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXRlbXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4zLjEuMVxuICAgICAgICB2YXIgdHlwZSA9IFV0aWxzLndoYXRJcyhzY2hlbWEuaXRlbXMpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKFwiaXRlbXNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEuaXRlbXMpO1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc2NoZW1hLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goXCJpdGVtc1wiKTtcbiAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKGlkeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEuaXRlbXNbaWR4XSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wiaXRlbXNcIiwgW1wiYXJyYXlcIiwgXCJvYmplY3RcIl1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1c3RvbSAtIHN0cmljdCBtb2RlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VBZGRpdGlvbmFsID09PSB0cnVlICYmIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJhZGRpdGlvbmFsSXRlbXNcIl0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN1c3RvbWUgLSBhc3N1bWUgZGVmaW5lZCBmYWxzZSBtb2RlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXNzdW1lQWRkaXRpb25hbCAmJiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1heEl0ZW1zOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMy4yLjFcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4SXRlbXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJtYXhJdGVtc1wiLCBcImludGVnZXJcIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5tYXhJdGVtcyA8IDApIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfTVVTVF9CRVwiLCBbXCJtYXhJdGVtc1wiLCBcImdyZWF0ZXIgdGhhbiwgb3IgZXF1YWwgdG8gMFwiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pbkl0ZW1zOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuMy4zLjFcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhzY2hlbWEubWluSXRlbXMpICE9PSBcImludGVnZXJcIikge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcIm1pbkl0ZW1zXCIsIFwiaW50ZWdlclwiXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLm1pbkl0ZW1zIDwgMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcIm1pbkl0ZW1zXCIsIFwiZ3JlYXRlciB0aGFuLCBvciBlcXVhbCB0byAwXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdW5pcXVlSXRlbXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS4zLjQuMVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS51bmlxdWVJdGVtcyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJ1bmlxdWVJdGVtc1wiLCBcImJvb2xlYW5cIl0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXhQcm9wZXJ0aWVzOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNC4xLjFcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhzY2hlbWEubWF4UHJvcGVydGllcykgIT09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wibWF4UHJvcGVydGllc1wiLCBcImludGVnZXJcIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5tYXhQcm9wZXJ0aWVzIDwgMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcIm1heFByb3BlcnRpZXNcIiwgXCJncmVhdGVyIHRoYW4sIG9yIGVxdWFsIHRvIDBcIl0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtaW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNC4yLjFcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhzY2hlbWEubWluUHJvcGVydGllcykgIT09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wibWluUHJvcGVydGllc1wiLCBcImludGVnZXJcIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5taW5Qcm9wZXJ0aWVzIDwgMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcIm1pblByb3BlcnRpZXNcIiwgXCJncmVhdGVyIHRoYW4sIG9yIGVxdWFsIHRvIDBcIl0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXF1aXJlZDogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjQuMy4xXG4gICAgICAgIGlmIChVdGlscy53aGF0SXMoc2NoZW1hLnJlcXVpcmVkKSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wicmVxdWlyZWRcIiwgXCJhcnJheVwiXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcInJlcXVpcmVkXCIsIFwiYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudFwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc2NoZW1hLnJlcXVpcmVkLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnJlcXVpcmVkW2lkeF0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9WQUxVRV9UWVBFXCIsIFtcInJlcXVpcmVkXCIsIFwic3RyaW5nXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNVbmlxdWVBcnJheShzY2hlbWEucmVxdWlyZWQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfTVVTVF9CRVwiLCBbXCJyZXF1aXJlZFwiLCBcImFuIGFycmF5IHdpdGggdW5pcXVlIGl0ZW1zXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS40LjQuMVxuICAgICAgICB2YXIgdHlwZSA9IFV0aWxzLndoYXRJcyhzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICBpZiAodHlwZSAhPT0gXCJib29sZWFuXCIgJiYgdHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl1dKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS40LjQuMVxuICAgICAgICBpZiAoVXRpbHMud2hhdElzKHNjaGVtYS5wcm9wZXJ0aWVzKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcInByb3BlcnRpZXNcIiwgXCJvYmplY3RcIl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyksXG4gICAgICAgICAgICBpZHggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpZHhdLFxuICAgICAgICAgICAgICAgIHZhbCA9IHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHZhbCk7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VzdG9tIC0gc3RyaWN0IG1vZGVcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZUFkZGl0aW9uYWwgPT09IHRydWUgJiYgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VzdG9tZSAtIGFzc3VtZSBkZWZpbmVkIGZhbHNlIG1vZGVcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3N1bWVBZGRpdGlvbmFsICYmIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXN0b20gLSBmb3JjZVByb3BlcnRpZXNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZVByb3BlcnRpZXMgPT09IHRydWUgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIkNVU1RPTV9NT0RFX0ZPUkNFX1BST1BFUlRJRVNcIiwgW1wicHJvcGVydGllc1wiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNC40LjFcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wicGF0dGVyblByb3BlcnRpZXNcIiwgXCJvYmplY3RcIl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpLFxuICAgICAgICAgICAgaWR4ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaWR4XSxcbiAgICAgICAgICAgICAgICB2YWwgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgUmVnRXhwKGtleSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9QQVRURVJOXCIsIFtcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsIGtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChcInBhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCB2YWwpO1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1c3RvbSAtIGZvcmNlUHJvcGVydGllc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlUHJvcGVydGllcyA9PT0gdHJ1ZSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiQ1VTVE9NX01PREVfRk9SQ0VfUFJPUEVSVElFU1wiLCBbXCJwYXR0ZXJuUHJvcGVydGllc1wiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjQuNS4xXG4gICAgICAgIGlmIChVdGlscy53aGF0SXMoc2NoZW1hLmRlcGVuZGVuY2llcykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJkZXBlbmRlbmNpZXNcIiwgXCJvYmplY3RcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAgICAgICBpZHggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWFLZXkgPSBrZXlzW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYURlcGVuZGVuY3kgPSBzY2hlbWEuZGVwZW5kZW5jaWVzW3NjaGVtYUtleV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBVdGlscy53aGF0SXMoc2NoZW1hRGVwZW5kZW5jeSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKFwiZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKHNjaGVtYUtleSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYURlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeDIgPSBzY2hlbWFEZXBlbmRlbmN5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfTVVTVF9CRVwiLCBbXCJkZXBlbmRlbmNpZXNcIiwgXCJub3QgZW1wdHkgYXJyYXlcIl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpZHgyLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hRGVwZW5kZW5jeVtpZHgyXSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVkFMVUVfVFlQRVwiLCBbXCJkZXBlbmRlbnNpY2VzXCIsIFwic3RyaW5nXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNVbmlxdWVBcnJheShzY2hlbWFEZXBlbmRlbmN5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfTVVTVF9CRVwiLCBbXCJkZXBlbmRlbmNpZXNcIiwgXCJhbiBhcnJheSB3aXRoIHVuaXF1ZSBpdGVtc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1ZBTFVFX1RZUEVcIiwgW1wiZGVwZW5kZW5jaWVzXCIsIFwib2JqZWN0IG9yIGFycmF5XCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVudW06IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS41LjEuMVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wiZW51bVwiLCBcImFycmF5XCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEuZW51bS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfTVVTVF9CRVwiLCBbXCJlbnVtXCIsIFwiYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudFwiXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNVbmlxdWVBcnJheShzY2hlbWEuZW51bSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX01VU1RfQkVcIiwgW1wiZW51bVwiLCBcImFuIGFycmF5IHdpdGggdW5pcXVlIGVsZW1lbnRzXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjUuMi4xXG4gICAgICAgIHZhciBwcmltaXRpdmVUeXBlcyA9IFtcImFycmF5XCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJudW1iZXJcIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwic3RyaW5nXCJdLFxuICAgICAgICAgICAgcHJpbWl0aXZlVHlwZVN0ciA9IHByaW1pdGl2ZVR5cGVzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpO1xuXG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc2NoZW1hLnR5cGUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByaW1pdGl2ZVR5cGVzLmluZGV4T2Yoc2NoZW1hLnR5cGVbaWR4XSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJ0eXBlXCIsIHByaW1pdGl2ZVR5cGVTdHJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNVbmlxdWVBcnJheShzY2hlbWEudHlwZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcInR5cGVcIiwgXCJhbiBvYmplY3Qgd2l0aCB1bmlxdWUgcHJvcGVydGllc1wiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlVHlwZXMuaW5kZXhPZihzY2hlbWEudHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcInR5cGVcIiwgcHJpbWl0aXZlVHlwZVN0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcInR5cGVcIiwgW1wic3RyaW5nXCIsIFwiYXJyYXlcIl1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9FbXB0eVN0cmluZ3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FycmF5ICYmIHNjaGVtYS50eXBlLmluZGV4T2YoXCJzdHJpbmdcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5taW5MZW5ndGggPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEuZW51bSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYS5mb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYS5taW5MZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vRW1wdHlBcnJheXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJhcnJheVwiIHx8IGlzQXJyYXkgJiYgc2NoZW1hLnR5cGUuaW5kZXhPZihcImFycmF5XCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEubWluSXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEubWluSXRlbXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlUHJvcGVydGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcIm9iamVjdFwiIHx8IGlzQXJyYXkgJiYgc2NoZW1hLnR5cGUuaW5kZXhPZihcIm9iamVjdFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCAmJiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1VOREVGSU5FRF9TVFJJQ1RcIiwgW1wicHJvcGVydGllc1wiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VJdGVtcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcImFycmF5XCIgfHwgaXNBcnJheSAmJiBzY2hlbWEudHlwZS5pbmRleE9mKFwiYXJyYXlcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJpdGVtc1wiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VNaW5JdGVtcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcImFycmF5XCIgfHwgaXNBcnJheSAmJiBzY2hlbWEudHlwZS5pbmRleE9mKFwiYXJyYXlcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5taW5JdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJtaW5JdGVtc1wiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VNYXhJdGVtcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcImFycmF5XCIgfHwgaXNBcnJheSAmJiBzY2hlbWEudHlwZS5pbmRleE9mKFwiYXJyYXlcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5tYXhJdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJtYXhJdGVtc1wiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VNaW5MZW5ndGggPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FycmF5ICYmIHNjaGVtYS50eXBlLmluZGV4T2YoXCJzdHJpbmdcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5taW5MZW5ndGggPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEuZm9ybWF0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLmVudW0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEucGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJtaW5MZW5ndGhcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlTWF4TGVuZ3RoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgaXNBcnJheSAmJiBzY2hlbWEudHlwZS5pbmRleE9mKFwic3RyaW5nXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEubWF4TGVuZ3RoID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLmZvcm1hdCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYS5lbnVtID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLnBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1VOREVGSU5FRF9TVFJJQ1RcIiwgW1wibWF4TGVuZ3RoXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFsbE9mOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNS4zLjFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJhbGxPZlwiLCBcImFycmF5XCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEuYWxsT2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX01VU1RfQkVcIiwgW1wiYWxsT2ZcIiwgXCJhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50XCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBzY2hlbWEuYWxsT2YubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChcImFsbE9mXCIpO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goaWR4LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYS5hbGxPZltpZHhdKTtcbiAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYW55T2Y6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNS41LjQuMVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcImFueU9mXCIsIFwiYXJyYXlcIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5hbnlPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfTVVTVF9CRVwiLCBbXCJhbnlPZlwiLCBcImFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnRcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHNjaGVtYS5hbnlPZi5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKFwiYW55T2ZcIik7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChpZHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy52YWxpZGF0ZVNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hLmFueU9mW2lkeF0pO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBvbmVPZjogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjUuNS4xXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wib25lT2ZcIiwgXCJhcnJheVwiXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLm9uZU9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9NVVNUX0JFXCIsIFtcIm9uZU9mXCIsIFwiYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudFwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc2NoZW1hLm9uZU9mLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goXCJvbmVPZlwiKTtcbiAgICAgICAgICAgICAgICByZXBvcnQucGF0aC5wdXNoKGlkeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEub25lT2ZbaWR4XSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi41LjUuNi4xXG4gICAgICAgIGlmIChVdGlscy53aGF0SXMoc2NoZW1hLm5vdCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJub3RcIiwgXCJvYmplY3RcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChcIm5vdFwiKTtcbiAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYS5ub3QpO1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZmluaXRpb25zOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjUuNS43LjFcbiAgICAgICAgaWYgKFV0aWxzLndoYXRJcyhzY2hlbWEuZGVmaW5pdGlvbnMpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wiZGVmaW5pdGlvbnNcIiwgXCJvYmplY3RcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEuZGVmaW5pdGlvbnMpLFxuICAgICAgICAgICAgICAgIGlkeCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gc2NoZW1hLmRlZmluaXRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChcImRlZmluaXRpb25zXCIpO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlU2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCB2YWwpO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRoLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5mb3JtYXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJmb3JtYXRcIiwgXCJzdHJpbmdcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEZvcm1hdFZhbGlkYXRvcnNbc2NoZW1hLmZvcm1hdF0gPT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuaWdub3JlVW5rbm93bkZvcm1hdHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJVTktOT1dOX0ZPUk1BVFwiLCBbc2NoZW1hLmZvcm1hdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBpZDogZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLWNvcmUuaHRtbCNyZmMuc2VjdGlvbi43LjJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVFlQRV9FWFBFQ1RFRFwiLCBbXCJpZFwiLCBcInN0cmluZ1wiXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiBmdW5jdGlvbiAocmVwb3J0LCBzY2hlbWEpIHtcbiAgICAgICAgLy8gaHR0cDovL2pzb24tc2NoZW1hLm9yZy9sYXRlc3QvanNvbi1zY2hlbWEtdmFsaWRhdGlvbi5odG1sI3JmYy5zZWN0aW9uLjYuMVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS50aXRsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9UWVBFX0VYUEVDVEVEXCIsIFtcInRpdGxlXCIsIFwic3RyaW5nXCJdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIChyZXBvcnQsIHNjaGVtYSkge1xuICAgICAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS12YWxpZGF0aW9uLmh0bWwjcmZjLnNlY3Rpb24uNi4xXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmRlc2NyaXB0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJLRVlXT1JEX1RZUEVfRVhQRUNURURcIiwgW1wiZGVzY3JpcHRpb25cIiwgXCJzdHJpbmdcIl0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gKC8qIHJlcG9ydCwgc2NoZW1hICovKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvbGF0ZXN0L2pzb24tc2NoZW1hLXZhbGlkYXRpb24uaHRtbCNyZmMuc2VjdGlvbi42LjJcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIHJlc3RyaWN0aW9ucyBwbGFjZWQgb24gdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC5cbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1JlcG9ydH0gcmVwb3J0XG4gKiBAcGFyYW0geypbXX0gYXJyXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciB2YWxpZGF0ZUFycmF5T2ZTY2hlbWFzID0gZnVuY3Rpb24gKHJlcG9ydCwgYXJyKSB7XG4gICAgdmFyIGlkeCA9IGFyci5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgIGV4cG9ydHMudmFsaWRhdGVTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIGFycltpZHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcG9ydC5pc1ZhbGlkKCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1JlcG9ydH0gcmVwb3J0XG4gKiBAcGFyYW0geyp9IHNjaGVtYVxuICovXG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hID0gZnVuY3Rpb24gKHJlcG9ydCwgc2NoZW1hKSB7XG5cbiAgICByZXBvcnQuY29tbW9uRXJyb3JNZXNzYWdlID0gXCJTQ0hFTUFfVkFMSURBVElPTl9GQUlMRURcIjtcblxuICAgIC8vIGlmIHNjaGVtYSBpcyBhbiBhcnJheSwgYXNzdW1lIGl0J3MgYW4gYXJyYXkgb2Ygc2NoZW1hc1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQXJyYXlPZlNjaGVtYXMuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSk7XG4gICAgfVxuXG4gICAgLy8gZG8gbm90IHJldmFsaWRhdGUgc2NoZW1hIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgb25jZVxuICAgIGlmIChzY2hlbWEuX18kdmFsaWRhdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmICRzY2hlbWEgaXMgcHJlc2VudCwgdGhpcyBzY2hlbWEgc2hvdWxkIHZhbGlkYXRlIGFnYWluc3QgdGhhdCAkc2NoZW1hXG4gICAgdmFyIGhhc1BhcmVudFNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hICYmIHNjaGVtYS5pZCAhPT0gc2NoZW1hLiRzY2hlbWE7XG4gICAgaWYgKGhhc1BhcmVudFNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hLl9fJHNjaGVtYVJlc29sdmVkICYmIHNjaGVtYS5fXyRzY2hlbWFSZXNvbHZlZCAhPT0gc2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgc3ViUmVwb3J0ID0gbmV3IFJlcG9ydChyZXBvcnQpO1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gSnNvblZhbGlkYXRpb24udmFsaWRhdGUuY2FsbCh0aGlzLCBzdWJSZXBvcnQsIHNjaGVtYS5fXyRzY2hlbWFSZXNvbHZlZCwgc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJQQVJFTlRfU0NIRU1BX1ZBTElEQVRJT05fRkFJTEVEXCIsIG51bGwsIHN1YlJlcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVVucmVzb2x2YWJsZVJlZmVyZW5jZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuYWRkRXJyb3IoXCJSRUZfVU5SRVNPTFZFRFwiLCBbc2NoZW1hLiRzY2hlbWFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9UeXBlbGVzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBpc3N1ZSAjMzYgLSBpbmhlcml0IHR5cGUgdG8gYW55T2YsIG9uZU9mLCBhbGxPZiBpZiBub1R5cGVsZXNzIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKHNjaGVtYS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFzID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB7IHNjaGVtYXMgPSBzY2hlbWFzLmNvbmNhdChzY2hlbWEuYW55T2YpOyB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7IHNjaGVtYXMgPSBzY2hlbWFzLmNvbmNhdChzY2hlbWEub25lT2YpOyB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7IHNjaGVtYXMgPSBzY2hlbWFzLmNvbmNhdChzY2hlbWEuYWxsT2YpOyB9XG4gICAgICAgICAgICBzY2hlbWFzLmZvckVhY2goZnVuY3Rpb24gKHNjaCkge1xuICAgICAgICAgICAgICAgIGlmICghc2NoLnR5cGUpIHsgc2NoLnR5cGUgPSBzY2hlbWEudHlwZTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kIGlzc3VlICMzNlxuICAgICAgICBpZiAoc2NoZW1hLmVudW0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc2NoZW1hLmFueU9mID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHNjaGVtYS5vbmVPZiA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzY2hlbWEubm90ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHNjaGVtYS4kcmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcG9ydC5hZGRFcnJvcihcIktFWVdPUkRfVU5ERUZJTkVEX1NUUklDVFwiLCBbXCJ0eXBlXCJdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKSxcbiAgICAgICAgaWR4ID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2lkeF07XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIl9fXCIpID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChTY2hlbWFWYWxpZGF0b3JzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2NoZW1hVmFsaWRhdG9yc1trZXldLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFoYXNQYXJlbnRTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9FeHRyYUtleXdvcmRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmFkZEVycm9yKFwiS0VZV09SRF9VTkVYUEVDVEVEXCIsIFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWNDaGVjayA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgIC8vIGJyZWFrIHJlY3Vyc2lvblxuICAgICAgICAgICAgdmFyIHRtcFNjaGVtYSA9IFV0aWxzLmNsb25lKHNjaGVtYSk7XG4gICAgICAgICAgICBkZWxldGUgdG1wU2NoZW1hLmVudW07XG4gICAgICAgICAgICBkZWxldGUgdG1wU2NoZW1hLmRlZmF1bHQ7XG5cbiAgICAgICAgICAgIHJlcG9ydC5wYXRoLnB1c2goXCJlbnVtXCIpO1xuICAgICAgICAgICAgaWR4ID0gc2NoZW1hLmVudW0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChpZHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgSnNvblZhbGlkYXRpb24udmFsaWRhdGUuY2FsbCh0aGlzLCByZXBvcnQsIHRtcFNjaGVtYSwgc2NoZW1hLmVudW1baWR4XSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LnBhdGgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmVwb3J0LnBhdGgucHVzaChcImRlZmF1bHRcIik7XG4gICAgICAgICAgICBKc29uVmFsaWRhdGlvbi52YWxpZGF0ZS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hLCBzY2hlbWEuZGVmYXVsdCk7XG4gICAgICAgICAgICByZXBvcnQucGF0aC5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1ZhbGlkID0gcmVwb3J0LmlzVmFsaWQoKTtcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICBzY2hlbWEuX18kdmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/SchemaValidation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/Utils.js":
/*!********************************************!*\
  !*** ./node_modules/z-schema/src/Utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.jsonSymbol = Symbol.for(\"z-schema/json\");\n\nexports.schemaSymbol = Symbol.for(\"z-schema/schema\");\n\n/**\n * @param {object} obj\n *\n * @returns {string[]}\n */\nvar sortedKeys = exports.sortedKeys = function (obj) {\n    return Object.keys(obj).sort();\n};\n\n/**\n *\n * @param {string} uri\n *\n * @returns {boolean}\n */\nexports.isAbsoluteUri = function (uri) {\n    return /^https?:\\/\\//.test(uri);\n};\n\n/**\n *\n * @param {string} uri\n *\n * @returns {boolean}\n */\nexports.isRelativeUri = function (uri) {\n    // relative URIs that end with a hash sign, issue #56\n    return /.+#/.test(uri);\n};\n\nexports.whatIs = function (what) {\n\n    var to = typeof what;\n\n    if (to === \"object\") {\n        if (what === null) {\n            return \"null\";\n        }\n        if (Array.isArray(what)) {\n            return \"array\";\n        }\n        return \"object\"; // typeof what === 'object' && what === Object(what) && !Array.isArray(what);\n    }\n\n    if (to === \"number\") {\n        if (Number.isFinite(what)) {\n            if (what % 1 === 0) {\n                return \"integer\";\n            } else {\n                return \"number\";\n            }\n        }\n        if (Number.isNaN(what)) {\n            return \"not-a-number\";\n        }\n        return \"unknown-number\";\n    }\n\n    return to; // undefined, boolean, string, function\n\n};\n\n/**\n *\n * @param {*} json1\n * @param {*} json2\n * @param {*} [options]\n *\n * @returns {boolean}\n */\nexports.areEqual = function areEqual(json1, json2, options) {\n\n    options = options || {};\n    var caseInsensitiveComparison = options.caseInsensitiveComparison || false;\n\n    // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6\n\n    // Two JSON values are said to be equal if and only if:\n    // both are nulls; or\n    // both are booleans, and have the same value; or\n    // both are strings, and have the same value; or\n    // both are numbers, and have the same mathematical value; or\n    if (json1 === json2) {\n        return true;\n    }\n    if (\n      caseInsensitiveComparison === true &&\n      typeof json1 === \"string\" && typeof json2 === \"string\" &&\n      json1.toUpperCase() === json2.toUpperCase()) {\n        return true;\n    }\n\n    var i, len;\n\n    // both are arrays, and:\n    if (Array.isArray(json1) && Array.isArray(json2)) {\n        // have the same number of items; and\n        if (json1.length !== json2.length) {\n            return false;\n        }\n        // items at the same index are equal according to this definition; or\n        len = json1.length;\n        for (i = 0; i < len; i++) {\n            if (!areEqual(json1[i], json2[i], { caseInsensitiveComparison: caseInsensitiveComparison })) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // both are objects, and:\n    if (exports.whatIs(json1) === \"object\" && exports.whatIs(json2) === \"object\") {\n        // have the same set of property names; and\n        var keys1 = sortedKeys(json1);\n        var keys2 = sortedKeys(json2);\n        if (!areEqual(keys1, keys2, { caseInsensitiveComparison: caseInsensitiveComparison })) {\n            return false;\n        }\n        // values for a same property name are equal according to this definition.\n        len = keys1.length;\n        for (i = 0; i < len; i++) {\n            if (!areEqual(json1[keys1[i]], json2[keys1[i]], { caseInsensitiveComparison: caseInsensitiveComparison })) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return false;\n};\n\n/**\n *\n * @param {*[]} arr\n * @param {number[]} [indexes]\n *\n * @returns {boolean}\n */\nexports.isUniqueArray = function (arr, indexes) {\n    var i, j, l = arr.length;\n    for (i = 0; i < l; i++) {\n        for (j = i + 1; j < l; j++) {\n            if (exports.areEqual(arr[i], arr[j])) {\n                if (indexes) { indexes.push(i, j); }\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\n/**\n *\n * @param {*} bigSet\n * @param {*} subSet\n *\n * @returns {*[]}\n */\nexports.difference = function (bigSet, subSet) {\n    var arr = [],\n        idx = bigSet.length;\n    while (idx--) {\n        if (subSet.indexOf(bigSet[idx]) === -1) {\n            arr.push(bigSet[idx]);\n        }\n    }\n    return arr;\n};\n\n// NOT a deep version of clone\nexports.clone = function (src) {\n    if (typeof src === \"undefined\") { return void 0; }\n    if (typeof src !== \"object\" || src === null) { return src; }\n    var res, idx;\n    if (Array.isArray(src)) {\n        res = [];\n        idx = src.length;\n        while (idx--) {\n            res[idx] = src[idx];\n        }\n    } else {\n        res = {};\n        var keys = Object.keys(src);\n        idx = keys.length;\n        while (idx--) {\n            var key = keys[idx];\n            res[key] = src[key];\n        }\n    }\n    return res;\n};\n\nexports.cloneDeep = function (src) {\n    var vidx = 0, visited = new Map(), cloned = [];\n    function cloneDeep(src) {\n        if (typeof src !== \"object\" || src === null) { return src; }\n        var res, idx, cidx;\n\n        cidx = visited.get(src);\n        if (cidx !== undefined) { return cloned[cidx]; }\n\n        visited.set(src, vidx++);\n        if (Array.isArray(src)) {\n            res = [];\n            cloned.push(res);\n            idx = src.length;\n            while (idx--) {\n                res[idx] = cloneDeep(src[idx]);\n            }\n        } else {\n            res = {};\n            cloned.push(res);\n            var keys = Object.keys(src);\n            idx = keys.length;\n            while (idx--) {\n                var key = keys[idx];\n                res[key] = cloneDeep(src[key]);\n            }\n        }\n        return res;\n    }\n    return cloneDeep(src);\n};\n\n/*\n  following function comes from punycode.js library\n  see: https://github.com/bestiejs/punycode.js\n*/\n/*jshint -W016*/\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nexports.ucs2decode = function (string) {\n    var output = [],\n        counter = 0,\n        length = string.length,\n        value,\n        extra;\n    while (counter < length) {\n        value = string.charCodeAt(counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // high surrogate, and there is a next character\n            extra = string.charCodeAt(counter++);\n            if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            } else {\n                // unmatched surrogate; only append this code unit, in case the next\n                // code unit is the high surrogate of a surrogate pair\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output;\n};\n/*jshint +W016*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQjs7QUFFbEIsb0JBQW9COztBQUVwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLGdEQUFnRCxzREFBc0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxzQ0FBc0Msc0RBQXNEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsOERBQThELHNEQUFzRDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qix3QkFBd0IsT0FBTztBQUMvQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixzQ0FBc0M7QUFDdEMsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxjQUFjO0FBQ2Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFx6LXNjaGVtYVxcc3JjXFxVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5qc29uU3ltYm9sID0gU3ltYm9sLmZvcihcInotc2NoZW1hL2pzb25cIik7XG5cbmV4cG9ydHMuc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInotc2NoZW1hL3NjaGVtYVwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG52YXIgc29ydGVkS2V5cyA9IGV4cG9ydHMuc29ydGVkS2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBYnNvbHV0ZVVyaSA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICByZXR1cm4gL15odHRwcz86XFwvXFwvLy50ZXN0KHVyaSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNSZWxhdGl2ZVVyaSA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAvLyByZWxhdGl2ZSBVUklzIHRoYXQgZW5kIHdpdGggYSBoYXNoIHNpZ24sIGlzc3VlICM1NlxuICAgIHJldHVybiAvLisjLy50ZXN0KHVyaSk7XG59O1xuXG5leHBvcnRzLndoYXRJcyA9IGZ1bmN0aW9uICh3aGF0KSB7XG5cbiAgICB2YXIgdG8gPSB0eXBlb2Ygd2hhdDtcblxuICAgIGlmICh0byA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAod2hhdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdoYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiOyAvLyB0eXBlb2Ygd2hhdCA9PT0gJ29iamVjdCcgJiYgd2hhdCA9PT0gT2JqZWN0KHdoYXQpICYmICFBcnJheS5pc0FycmF5KHdoYXQpO1xuICAgIH1cblxuICAgIGlmICh0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHdoYXQpKSB7XG4gICAgICAgICAgICBpZiAod2hhdCAlIDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRlZ2VyXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4od2hhdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm5vdC1hLW51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInVua25vd24tbnVtYmVyXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvOyAvLyB1bmRlZmluZWQsIGJvb2xlYW4sIHN0cmluZywgZnVuY3Rpb25cblxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBqc29uMVxuICogQHBhcmFtIHsqfSBqc29uMlxuICogQHBhcmFtIHsqfSBbb3B0aW9uc11cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5hcmVFcXVhbCA9IGZ1bmN0aW9uIGFyZUVxdWFsKGpzb24xLCBqc29uMiwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmlzb24gPSBvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZUNvbXBhcmlzb24gfHwgZmFsc2U7XG5cbiAgICAvLyBodHRwOi8vanNvbi1zY2hlbWEub3JnL2xhdGVzdC9qc29uLXNjaGVtYS1jb3JlLmh0bWwjcmZjLnNlY3Rpb24uMy42XG5cbiAgICAvLyBUd28gSlNPTiB2YWx1ZXMgYXJlIHNhaWQgdG8gYmUgZXF1YWwgaWYgYW5kIG9ubHkgaWY6XG4gICAgLy8gYm90aCBhcmUgbnVsbHM7IG9yXG4gICAgLy8gYm90aCBhcmUgYm9vbGVhbnMsIGFuZCBoYXZlIHRoZSBzYW1lIHZhbHVlOyBvclxuICAgIC8vIGJvdGggYXJlIHN0cmluZ3MsIGFuZCBoYXZlIHRoZSBzYW1lIHZhbHVlOyBvclxuICAgIC8vIGJvdGggYXJlIG51bWJlcnMsIGFuZCBoYXZlIHRoZSBzYW1lIG1hdGhlbWF0aWNhbCB2YWx1ZTsgb3JcbiAgICBpZiAoanNvbjEgPT09IGpzb24yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBjYXNlSW5zZW5zaXRpdmVDb21wYXJpc29uID09PSB0cnVlICYmXG4gICAgICB0eXBlb2YganNvbjEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGpzb24yID09PSBcInN0cmluZ1wiICYmXG4gICAgICBqc29uMS50b1VwcGVyQ2FzZSgpID09PSBqc29uMi50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpLCBsZW47XG5cbiAgICAvLyBib3RoIGFyZSBhcnJheXMsIGFuZDpcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uMSkgJiYgQXJyYXkuaXNBcnJheShqc29uMikpIHtcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgaXRlbXM7IGFuZFxuICAgICAgICBpZiAoanNvbjEubGVuZ3RoICE9PSBqc29uMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcmUgZXF1YWwgYWNjb3JkaW5nIHRvIHRoaXMgZGVmaW5pdGlvbjsgb3JcbiAgICAgICAgbGVuID0ganNvbjEubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJlRXF1YWwoanNvbjFbaV0sIGpzb24yW2ldLCB7IGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmlzb246IGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmlzb24gfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gYm90aCBhcmUgb2JqZWN0cywgYW5kOlxuICAgIGlmIChleHBvcnRzLndoYXRJcyhqc29uMSkgPT09IFwib2JqZWN0XCIgJiYgZXhwb3J0cy53aGF0SXMoanNvbjIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGhhdmUgdGhlIHNhbWUgc2V0IG9mIHByb3BlcnR5IG5hbWVzOyBhbmRcbiAgICAgICAgdmFyIGtleXMxID0gc29ydGVkS2V5cyhqc29uMSk7XG4gICAgICAgIHZhciBrZXlzMiA9IHNvcnRlZEtleXMoanNvbjIpO1xuICAgICAgICBpZiAoIWFyZUVxdWFsKGtleXMxLCBrZXlzMiwgeyBjYXNlSW5zZW5zaXRpdmVDb21wYXJpc29uOiBjYXNlSW5zZW5zaXRpdmVDb21wYXJpc29uIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFsdWVzIGZvciBhIHNhbWUgcHJvcGVydHkgbmFtZSBhcmUgZXF1YWwgYWNjb3JkaW5nIHRvIHRoaXMgZGVmaW5pdGlvbi5cbiAgICAgICAgbGVuID0ga2V5czEubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJlRXF1YWwoanNvbjFba2V5czFbaV1dLCBqc29uMltrZXlzMVtpXV0sIHsgY2FzZUluc2Vuc2l0aXZlQ29tcGFyaXNvbjogY2FzZUluc2Vuc2l0aXZlQ29tcGFyaXNvbiB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geypbXX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcltdfSBbaW5kZXhlc11cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1VuaXF1ZUFycmF5ID0gZnVuY3Rpb24gKGFyciwgaW5kZXhlcykge1xuICAgIHZhciBpLCBqLCBsID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5hcmVFcXVhbChhcnJbaV0sIGFycltqXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhlcykgeyBpbmRleGVzLnB1c2goaSwgaik7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGJpZ1NldFxuICogQHBhcmFtIHsqfSBzdWJTZXRcbiAqXG4gKiBAcmV0dXJucyB7KltdfVxuICovXG5leHBvcnRzLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYmlnU2V0LCBzdWJTZXQpIHtcbiAgICB2YXIgYXJyID0gW10sXG4gICAgICAgIGlkeCA9IGJpZ1NldC5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgIGlmIChzdWJTZXQuaW5kZXhPZihiaWdTZXRbaWR4XSkgPT09IC0xKSB7XG4gICAgICAgICAgICBhcnIucHVzaChiaWdTZXRbaWR4XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbi8vIE5PVCBhIGRlZXAgdmVyc2lvbiBvZiBjbG9uZVxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm4gdm9pZCAwOyB9XG4gICAgaWYgKHR5cGVvZiBzcmMgIT09IFwib2JqZWN0XCIgfHwgc3JjID09PSBudWxsKSB7IHJldHVybiBzcmM7IH1cbiAgICB2YXIgcmVzLCBpZHg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgaWR4ID0gc3JjLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICByZXNbaWR4XSA9IHNyY1tpZHhdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICAgICAgaWR4ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaWR4XTtcbiAgICAgICAgICAgIHJlc1trZXldID0gc3JjW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmV4cG9ydHMuY2xvbmVEZWVwID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHZhciB2aWR4ID0gMCwgdmlzaXRlZCA9IG5ldyBNYXAoKSwgY2xvbmVkID0gW107XG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gXCJvYmplY3RcIiB8fCBzcmMgPT09IG51bGwpIHsgcmV0dXJuIHNyYzsgfVxuICAgICAgICB2YXIgcmVzLCBpZHgsIGNpZHg7XG5cbiAgICAgICAgY2lkeCA9IHZpc2l0ZWQuZ2V0KHNyYyk7XG4gICAgICAgIGlmIChjaWR4ICE9PSB1bmRlZmluZWQpIHsgcmV0dXJuIGNsb25lZFtjaWR4XTsgfVxuXG4gICAgICAgIHZpc2l0ZWQuc2V0KHNyYywgdmlkeCsrKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBjbG9uZWQucHVzaChyZXMpO1xuICAgICAgICAgICAgaWR4ID0gc3JjLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICAgICAgICAgIHJlc1tpZHhdID0gY2xvbmVEZWVwKHNyY1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHt9O1xuICAgICAgICAgICAgY2xvbmVkLnB1c2gocmVzKTtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICAgICAgICAgIGlkeCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaWR4XTtcbiAgICAgICAgICAgICAgICByZXNba2V5XSA9IGNsb25lRGVlcChzcmNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lRGVlcChzcmMpO1xufTtcblxuLypcbiAgZm9sbG93aW5nIGZ1bmN0aW9uIGNvbWVzIGZyb20gcHVueWNvZGUuanMgbGlicmFyeVxuICBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qc1xuKi9cbi8qanNoaW50IC1XMDE2Ki9cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmV4cG9ydHMudWNzMmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgIGNvdW50ZXIgPSAwLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZXh0cmE7XG4gICAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLypqc2hpbnQgK1cwMTYqL1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/Utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/ZSchema.js":
/*!**********************************************!*\
  !*** ./node_modules/z-schema/src/ZSchema.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! ./Polyfills */ \"(rsc)/./node_modules/z-schema/src/Polyfills.js\");\nvar get               = __webpack_require__(/*! lodash.get */ \"(rsc)/./node_modules/lodash.get/index.js\");\nvar Report            = __webpack_require__(/*! ./Report */ \"(rsc)/./node_modules/z-schema/src/Report.js\");\nvar FormatValidators  = __webpack_require__(/*! ./FormatValidators */ \"(rsc)/./node_modules/z-schema/src/FormatValidators.js\");\nvar JsonValidation    = __webpack_require__(/*! ./JsonValidation */ \"(rsc)/./node_modules/z-schema/src/JsonValidation.js\");\nvar SchemaCache       = __webpack_require__(/*! ./SchemaCache */ \"(rsc)/./node_modules/z-schema/src/SchemaCache.js\");\nvar SchemaCompilation = __webpack_require__(/*! ./SchemaCompilation */ \"(rsc)/./node_modules/z-schema/src/SchemaCompilation.js\");\nvar SchemaValidation  = __webpack_require__(/*! ./SchemaValidation */ \"(rsc)/./node_modules/z-schema/src/SchemaValidation.js\");\nvar Utils             = __webpack_require__(/*! ./Utils */ \"(rsc)/./node_modules/z-schema/src/Utils.js\");\nvar Draft4Schema      = __webpack_require__(/*! ./schemas/schema.json */ \"(rsc)/./node_modules/z-schema/src/schemas/schema.json\");\nvar Draft4HyperSchema = __webpack_require__(/*! ./schemas/hyper-schema.json */ \"(rsc)/./node_modules/z-schema/src/schemas/hyper-schema.json\");\n\n/**\n * default options\n */\nvar defaultOptions = {\n    // default timeout for all async tasks\n    asyncTimeout: 2000,\n    // force additionalProperties and additionalItems to be defined on \"object\" and \"array\" types\n    forceAdditional: false,\n    // assume additionalProperties and additionalItems are defined as \"false\" where appropriate\n    assumeAdditional: false,\n    // do case insensitive comparison for enums\n    enumCaseInsensitiveComparison: false,\n    // force items to be defined on \"array\" types\n    forceItems: false,\n    // force minItems to be defined on \"array\" types\n    forceMinItems: false,\n    // force maxItems to be defined on \"array\" types\n    forceMaxItems: false,\n    // force minLength to be defined on \"string\" types\n    forceMinLength: false,\n    // force maxLength to be defined on \"string\" types\n    forceMaxLength: false,\n    // force properties or patternProperties to be defined on \"object\" types\n    forceProperties: false,\n    // ignore references that cannot be resolved (remote schemas) // TODO: make sure this is only for remote schemas, not local ones\n    ignoreUnresolvableReferences: false,\n    // disallow usage of keywords that this validator can't handle\n    noExtraKeywords: false,\n    // disallow usage of schema's without \"type\" defined\n    noTypeless: false,\n    // disallow zero length strings in validated objects\n    noEmptyStrings: false,\n    // disallow zero length arrays in validated objects\n    noEmptyArrays: false,\n    // forces \"uri\" format to be in fully rfc3986 compliant\n    strictUris: false,\n    // turn on some of the above\n    strictMode: false,\n    // report error paths as an array of path segments to get to the offending node\n    reportPathAsArray: false,\n    // stop validation as soon as an error is found\n    breakOnFirstError: false,\n    // check if schema follows best practices and common sense\n    pedanticCheck: false,\n    // ignore unknown formats (do not report them as an error)\n    ignoreUnknownFormats: false,\n    // function to be called on every schema\n    customValidator: null\n};\n\nfunction normalizeOptions(options) {\n    var normalized;\n\n    // options\n    if (typeof options === \"object\") {\n        var keys = Object.keys(options),\n            idx = keys.length,\n            key;\n\n        // check that the options are correctly configured\n        while (idx--) {\n            key = keys[idx];\n            if (defaultOptions[key] === undefined) {\n                throw new Error(\"Unexpected option passed to constructor: \" + key);\n            }\n        }\n\n        // copy the default options into passed options\n        keys = Object.keys(defaultOptions);\n        idx = keys.length;\n        while (idx--) {\n            key = keys[idx];\n            if (options[key] === undefined) {\n                options[key] = Utils.clone(defaultOptions[key]);\n            }\n        }\n\n        normalized = options;\n    } else {\n        normalized = Utils.clone(defaultOptions);\n    }\n\n    if (normalized.strictMode === true) {\n        normalized.forceAdditional  = true;\n        normalized.forceItems       = true;\n        normalized.forceMaxLength   = true;\n        normalized.forceProperties  = true;\n        normalized.noExtraKeywords  = true;\n        normalized.noTypeless       = true;\n        normalized.noEmptyStrings   = true;\n        normalized.noEmptyArrays    = true;\n    }\n\n    return normalized;\n}\n\n/**\n * @class\n *\n * @param {*} [options]\n */\nfunction ZSchema(options) {\n    this.cache = {};\n    this.referenceCache = [];\n    this.validateOptions = {};\n\n    this.options = normalizeOptions(options);\n\n    // Disable strict validation for the built-in schemas\n    var metaschemaOptions = normalizeOptions({ });\n\n    this.setRemoteReference(\"http://json-schema.org/draft-04/schema\", Draft4Schema, metaschemaOptions);\n    this.setRemoteReference(\"http://json-schema.org/draft-04/hyper-schema\", Draft4HyperSchema, metaschemaOptions);\n}\n\n/**\n * instance methods\n *\n * @param {*} schema\n *\n * @returns {boolean}\n */\nZSchema.prototype.compileSchema = function (schema) {\n    var report = new Report(this.options);\n\n    schema = SchemaCache.getSchema.call(this, report, schema);\n\n    SchemaCompilation.compileSchema.call(this, report, schema);\n\n    this.lastReport = report;\n    return report.isValid();\n};\n\n/**\n *\n * @param {*} schema\n *\n * @returns {boolean}\n */\nZSchema.prototype.validateSchema = function (schema) {\n    if (Array.isArray(schema) && schema.length === 0) {\n        throw new Error(\".validateSchema was called with an empty array\");\n    }\n\n    var report = new Report(this.options);\n\n    schema = SchemaCache.getSchema.call(this, report, schema);\n\n    var compiled = SchemaCompilation.compileSchema.call(this, report, schema);\n    if (compiled) { SchemaValidation.validateSchema.call(this, report, schema); }\n\n    this.lastReport = report;\n    return report.isValid();\n};\n\n/**\n *\n * @param {*} json\n * @param {*} schema\n * @param {*} [options]\n * @param {function(*, *)} [callback]\n *\n * @returns {boolean}\n */\nZSchema.prototype.validate = function (json, schema, options, callback) {\n\n    if (Utils.whatIs(options) === \"function\") {\n        callback = options;\n        options = {};\n    }\n    if (!options) { options = {}; }\n\n    this.validateOptions = options;\n\n    var whatIs = Utils.whatIs(schema);\n    if (whatIs !== \"string\" && whatIs !== \"object\") {\n        var e = new Error(\"Invalid .validate call - schema must be a string or object but \" + whatIs + \" was passed!\");\n        if (callback) {\n            process.nextTick(function () {\n                callback(e, false);\n            });\n            return;\n        }\n        throw e;\n    }\n\n    var foundError = false;\n    var report = new Report(this.options);\n    report.json = json;\n\n    if (typeof schema === \"string\") {\n        var schemaName = schema;\n        schema = SchemaCache.getSchema.call(this, report, schemaName);\n        if (!schema) {\n            throw new Error(\"Schema with id '\" + schemaName + \"' wasn't found in the validator cache!\");\n        }\n    } else {\n        schema = SchemaCache.getSchema.call(this, report, schema);\n    }\n\n    var compiled = false;\n    if (!foundError) {\n        compiled = SchemaCompilation.compileSchema.call(this, report, schema);\n    }\n    if (!compiled) {\n        this.lastReport = report;\n        foundError = true;\n    }\n\n    var validated = false;\n    if (!foundError) {\n        validated = SchemaValidation.validateSchema.call(this, report, schema);\n    }\n    if (!validated) {\n        this.lastReport = report;\n        foundError = true;\n    }\n\n    if (options.schemaPath) {\n        report.rootSchema = schema;\n        schema = get(schema, options.schemaPath);\n        if (!schema) {\n            throw new Error(\"Schema path '\" + options.schemaPath + \"' wasn't found in the schema!\");\n        }\n    }\n\n    if (!foundError) {\n        JsonValidation.validate.call(this, report, schema, json);\n    }\n\n    if (callback) {\n        report.processAsyncTasks(this.options.asyncTimeout, callback);\n        return;\n    } else if (report.asyncTasks.length > 0) {\n        throw new Error(\"This validation has async tasks and cannot be done in sync mode, please provide callback argument.\");\n    }\n\n    // assign lastReport so errors are retrievable in sync mode\n    this.lastReport = report;\n    return report.isValid();\n};\nZSchema.prototype.getLastError = function () {\n    if (this.lastReport.errors.length === 0) {\n        return null;\n    }\n    var e = new Error();\n    e.name = \"z-schema validation error\";\n    e.message = this.lastReport.commonErrorMessage;\n    e.details = this.lastReport.errors;\n    return e;\n};\nZSchema.prototype.getLastErrors = function () {\n    return this.lastReport && this.lastReport.errors.length > 0 ? this.lastReport.errors : null;\n};\nZSchema.prototype.getMissingReferences = function (arr) {\n    arr = arr || this.lastReport.errors;\n    var res = [],\n        idx = arr.length;\n    while (idx--) {\n        var error = arr[idx];\n        if (error.code === \"UNRESOLVABLE_REFERENCE\") {\n            var reference = error.params[0];\n            if (res.indexOf(reference) === -1) {\n                res.push(reference);\n            }\n        }\n        if (error.inner) {\n            res = res.concat(this.getMissingReferences(error.inner));\n        }\n    }\n    return res;\n};\nZSchema.prototype.getMissingRemoteReferences = function () {\n    var missingReferences = this.getMissingReferences(),\n        missingRemoteReferences = [],\n        idx = missingReferences.length;\n    while (idx--) {\n        var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);\n        if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {\n            missingRemoteReferences.push(remoteReference);\n        }\n    }\n    return missingRemoteReferences;\n};\nZSchema.prototype.setRemoteReference = function (uri, schema, validationOptions) {\n    if (typeof schema === \"string\") {\n        schema = JSON.parse(schema);\n    } else {\n        schema = Utils.cloneDeep(schema);\n    }\n\n    if (validationOptions) {\n        schema.__$validationOptions = normalizeOptions(validationOptions);\n    }\n\n    SchemaCache.cacheSchemaByUri.call(this, uri, schema);\n};\nZSchema.prototype.getResolvedSchema = function (schema) {\n    var report = new Report(this.options);\n    schema = SchemaCache.getSchema.call(this, report, schema);\n\n    // clone before making any modifications\n    schema = Utils.cloneDeep(schema);\n\n    var visited = [];\n\n    // clean-up the schema and resolve references\n    var cleanup = function (schema) {\n        var key,\n            typeOf = Utils.whatIs(schema);\n        if (typeOf !== \"object\" && typeOf !== \"array\") {\n            return;\n        }\n\n        if (schema.___$visited) {\n            return;\n        }\n\n        schema.___$visited = true;\n        visited.push(schema);\n\n        if (schema.$ref && schema.__$refResolved) {\n            var from = schema.__$refResolved;\n            var to = schema;\n            delete schema.$ref;\n            delete schema.__$refResolved;\n            for (key in from) {\n                if (from.hasOwnProperty(key)) {\n                    to[key] = from[key];\n                }\n            }\n        }\n        for (key in schema) {\n            if (schema.hasOwnProperty(key)) {\n                if (key.indexOf(\"__$\") === 0) {\n                    delete schema[key];\n                } else {\n                    cleanup(schema[key]);\n                }\n            }\n        }\n    };\n\n    cleanup(schema);\n    visited.forEach(function (s) {\n        delete s.___$visited;\n    });\n\n    this.lastReport = report;\n    if (report.isValid()) {\n        return schema;\n    } else {\n        throw this.getLastError();\n    }\n};\n\n/**\n *\n * @param {*} schemaReader\n *\n * @returns {void}\n */\nZSchema.prototype.setSchemaReader = function (schemaReader) {\n    return ZSchema.setSchemaReader(schemaReader);\n};\n\nZSchema.prototype.getSchemaReader = function () {\n    return ZSchema.schemaReader;\n};\n\nZSchema.schemaReader = undefined;\n/*\n    static methods\n*/\nZSchema.setSchemaReader = function (schemaReader) {\n    ZSchema.schemaReader = schemaReader;\n};\nZSchema.registerFormat = function (formatName, validatorFunction) {\n    FormatValidators[formatName] = validatorFunction;\n};\nZSchema.unregisterFormat = function (formatName) {\n    delete FormatValidators[formatName];\n};\nZSchema.getRegisteredFormats = function () {\n    return Object.keys(FormatValidators);\n};\nZSchema.getDefaultOptions = function () {\n    return Utils.cloneDeep(defaultOptions);\n};\n\nZSchema.schemaSymbol = Utils.schemaSymbol;\n\nZSchema.jsonSymbol = Utils.jsonSymbol;\n\nmodule.exports = ZSchema;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvei1zY2hlbWEvc3JjL1pTY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQix3QkFBd0IsbUJBQU8sQ0FBQyw0REFBWTtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyw2REFBVTtBQUMxQyx3QkFBd0IsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDcEQsd0JBQXdCLG1CQUFPLENBQUMsNkVBQWtCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLHVFQUFlO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLG1GQUFxQjtBQUNyRCx3QkFBd0IsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDcEQsd0JBQXdCLG1CQUFPLENBQUMsMkRBQVM7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQXVCO0FBQ3ZELHdCQUF3QixtQkFBTyxDQUFDLGdHQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEhhcnl1NTQxMlxcRGVza3RvcFxcU2Nob29sXFxjYXBzdG9uZVxccGljc2VsXFxiYWNrZW5kXFxub2RlX21vZHVsZXNcXHotc2NoZW1hXFxzcmNcXFpTY2hlbWEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuL1BvbHlmaWxsc1wiKTtcbnZhciBnZXQgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2guZ2V0XCIpO1xudmFyIFJlcG9ydCAgICAgICAgICAgID0gcmVxdWlyZShcIi4vUmVwb3J0XCIpO1xudmFyIEZvcm1hdFZhbGlkYXRvcnMgID0gcmVxdWlyZShcIi4vRm9ybWF0VmFsaWRhdG9yc1wiKTtcbnZhciBKc29uVmFsaWRhdGlvbiAgICA9IHJlcXVpcmUoXCIuL0pzb25WYWxpZGF0aW9uXCIpO1xudmFyIFNjaGVtYUNhY2hlICAgICAgID0gcmVxdWlyZShcIi4vU2NoZW1hQ2FjaGVcIik7XG52YXIgU2NoZW1hQ29tcGlsYXRpb24gPSByZXF1aXJlKFwiLi9TY2hlbWFDb21waWxhdGlvblwiKTtcbnZhciBTY2hlbWFWYWxpZGF0aW9uICA9IHJlcXVpcmUoXCIuL1NjaGVtYVZhbGlkYXRpb25cIik7XG52YXIgVXRpbHMgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbnZhciBEcmFmdDRTY2hlbWEgICAgICA9IHJlcXVpcmUoXCIuL3NjaGVtYXMvc2NoZW1hLmpzb25cIik7XG52YXIgRHJhZnQ0SHlwZXJTY2hlbWEgPSByZXF1aXJlKFwiLi9zY2hlbWFzL2h5cGVyLXNjaGVtYS5qc29uXCIpO1xuXG4vKipcbiAqIGRlZmF1bHQgb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gZGVmYXVsdCB0aW1lb3V0IGZvciBhbGwgYXN5bmMgdGFza3NcbiAgICBhc3luY1RpbWVvdXQ6IDIwMDAsXG4gICAgLy8gZm9yY2UgYWRkaXRpb25hbFByb3BlcnRpZXMgYW5kIGFkZGl0aW9uYWxJdGVtcyB0byBiZSBkZWZpbmVkIG9uIFwib2JqZWN0XCIgYW5kIFwiYXJyYXlcIiB0eXBlc1xuICAgIGZvcmNlQWRkaXRpb25hbDogZmFsc2UsXG4gICAgLy8gYXNzdW1lIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGFuZCBhZGRpdGlvbmFsSXRlbXMgYXJlIGRlZmluZWQgYXMgXCJmYWxzZVwiIHdoZXJlIGFwcHJvcHJpYXRlXG4gICAgYXNzdW1lQWRkaXRpb25hbDogZmFsc2UsXG4gICAgLy8gZG8gY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uIGZvciBlbnVtc1xuICAgIGVudW1DYXNlSW5zZW5zaXRpdmVDb21wYXJpc29uOiBmYWxzZSxcbiAgICAvLyBmb3JjZSBpdGVtcyB0byBiZSBkZWZpbmVkIG9uIFwiYXJyYXlcIiB0eXBlc1xuICAgIGZvcmNlSXRlbXM6IGZhbHNlLFxuICAgIC8vIGZvcmNlIG1pbkl0ZW1zIHRvIGJlIGRlZmluZWQgb24gXCJhcnJheVwiIHR5cGVzXG4gICAgZm9yY2VNaW5JdGVtczogZmFsc2UsXG4gICAgLy8gZm9yY2UgbWF4SXRlbXMgdG8gYmUgZGVmaW5lZCBvbiBcImFycmF5XCIgdHlwZXNcbiAgICBmb3JjZU1heEl0ZW1zOiBmYWxzZSxcbiAgICAvLyBmb3JjZSBtaW5MZW5ndGggdG8gYmUgZGVmaW5lZCBvbiBcInN0cmluZ1wiIHR5cGVzXG4gICAgZm9yY2VNaW5MZW5ndGg6IGZhbHNlLFxuICAgIC8vIGZvcmNlIG1heExlbmd0aCB0byBiZSBkZWZpbmVkIG9uIFwic3RyaW5nXCIgdHlwZXNcbiAgICBmb3JjZU1heExlbmd0aDogZmFsc2UsXG4gICAgLy8gZm9yY2UgcHJvcGVydGllcyBvciBwYXR0ZXJuUHJvcGVydGllcyB0byBiZSBkZWZpbmVkIG9uIFwib2JqZWN0XCIgdHlwZXNcbiAgICBmb3JjZVByb3BlcnRpZXM6IGZhbHNlLFxuICAgIC8vIGlnbm9yZSByZWZlcmVuY2VzIHRoYXQgY2Fubm90IGJlIHJlc29sdmVkIChyZW1vdGUgc2NoZW1hcykgLy8gVE9ETzogbWFrZSBzdXJlIHRoaXMgaXMgb25seSBmb3IgcmVtb3RlIHNjaGVtYXMsIG5vdCBsb2NhbCBvbmVzXG4gICAgaWdub3JlVW5yZXNvbHZhYmxlUmVmZXJlbmNlczogZmFsc2UsXG4gICAgLy8gZGlzYWxsb3cgdXNhZ2Ugb2Yga2V5d29yZHMgdGhhdCB0aGlzIHZhbGlkYXRvciBjYW4ndCBoYW5kbGVcbiAgICBub0V4dHJhS2V5d29yZHM6IGZhbHNlLFxuICAgIC8vIGRpc2FsbG93IHVzYWdlIG9mIHNjaGVtYSdzIHdpdGhvdXQgXCJ0eXBlXCIgZGVmaW5lZFxuICAgIG5vVHlwZWxlc3M6IGZhbHNlLFxuICAgIC8vIGRpc2FsbG93IHplcm8gbGVuZ3RoIHN0cmluZ3MgaW4gdmFsaWRhdGVkIG9iamVjdHNcbiAgICBub0VtcHR5U3RyaW5nczogZmFsc2UsXG4gICAgLy8gZGlzYWxsb3cgemVybyBsZW5ndGggYXJyYXlzIGluIHZhbGlkYXRlZCBvYmplY3RzXG4gICAgbm9FbXB0eUFycmF5czogZmFsc2UsXG4gICAgLy8gZm9yY2VzIFwidXJpXCIgZm9ybWF0IHRvIGJlIGluIGZ1bGx5IHJmYzM5ODYgY29tcGxpYW50XG4gICAgc3RyaWN0VXJpczogZmFsc2UsXG4gICAgLy8gdHVybiBvbiBzb21lIG9mIHRoZSBhYm92ZVxuICAgIHN0cmljdE1vZGU6IGZhbHNlLFxuICAgIC8vIHJlcG9ydCBlcnJvciBwYXRocyBhcyBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHRvIGdldCB0byB0aGUgb2ZmZW5kaW5nIG5vZGVcbiAgICByZXBvcnRQYXRoQXNBcnJheTogZmFsc2UsXG4gICAgLy8gc3RvcCB2YWxpZGF0aW9uIGFzIHNvb24gYXMgYW4gZXJyb3IgaXMgZm91bmRcbiAgICBicmVha09uRmlyc3RFcnJvcjogZmFsc2UsXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1hIGZvbGxvd3MgYmVzdCBwcmFjdGljZXMgYW5kIGNvbW1vbiBzZW5zZVxuICAgIHBlZGFudGljQ2hlY2s6IGZhbHNlLFxuICAgIC8vIGlnbm9yZSB1bmtub3duIGZvcm1hdHMgKGRvIG5vdCByZXBvcnQgdGhlbSBhcyBhbiBlcnJvcilcbiAgICBpZ25vcmVVbmtub3duRm9ybWF0czogZmFsc2UsXG4gICAgLy8gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IHNjaGVtYVxuICAgIGN1c3RvbVZhbGlkYXRvcjogbnVsbFxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQ7XG5cbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyksXG4gICAgICAgICAgICBpZHggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBvcHRpb25zIGFyZSBjb3JyZWN0bHkgY29uZmlndXJlZFxuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaWR4XTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0T3B0aW9uc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG9wdGlvbiBwYXNzZWQgdG8gY29uc3RydWN0b3I6IFwiICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvcHkgdGhlIGRlZmF1bHQgb3B0aW9ucyBpbnRvIHBhc3NlZCBvcHRpb25zXG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIGlkeCA9IGtleXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaWR4XTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IFV0aWxzLmNsb25lKGRlZmF1bHRPcHRpb25zW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZCA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZCA9IFV0aWxzLmNsb25lKGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZC5zdHJpY3RNb2RlID09PSB0cnVlKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuZm9yY2VBZGRpdGlvbmFsICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQuZm9yY2VJdGVtcyAgICAgICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQuZm9yY2VNYXhMZW5ndGggICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQuZm9yY2VQcm9wZXJ0aWVzICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQubm9FeHRyYUtleXdvcmRzICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQubm9UeXBlbGVzcyAgICAgICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQubm9FbXB0eVN0cmluZ3MgICA9IHRydWU7XG4gICAgICAgIG5vcm1hbGl6ZWQubm9FbXB0eUFycmF5cyAgICA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8qKlxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIHsqfSBbb3B0aW9uc11cbiAqL1xuZnVuY3Rpb24gWlNjaGVtYShvcHRpb25zKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIHRoaXMucmVmZXJlbmNlQ2FjaGUgPSBbXTtcbiAgICB0aGlzLnZhbGlkYXRlT3B0aW9ucyA9IHt9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIERpc2FibGUgc3RyaWN0IHZhbGlkYXRpb24gZm9yIHRoZSBidWlsdC1pbiBzY2hlbWFzXG4gICAgdmFyIG1ldGFzY2hlbWFPcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyh7IH0pO1xuXG4gICAgdGhpcy5zZXRSZW1vdGVSZWZlcmVuY2UoXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYVwiLCBEcmFmdDRTY2hlbWEsIG1ldGFzY2hlbWFPcHRpb25zKTtcbiAgICB0aGlzLnNldFJlbW90ZVJlZmVyZW5jZShcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvaHlwZXItc2NoZW1hXCIsIERyYWZ0NEh5cGVyU2NoZW1hLCBtZXRhc2NoZW1hT3B0aW9ucyk7XG59XG5cbi8qKlxuICogaW5zdGFuY2UgbWV0aG9kc1xuICpcbiAqIEBwYXJhbSB7Kn0gc2NoZW1hXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblpTY2hlbWEucHJvdG90eXBlLmNvbXBpbGVTY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgdmFyIHJlcG9ydCA9IG5ldyBSZXBvcnQodGhpcy5vcHRpb25zKTtcblxuICAgIHNjaGVtYSA9IFNjaGVtYUNhY2hlLmdldFNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcblxuICAgIFNjaGVtYUNvbXBpbGF0aW9uLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSk7XG5cbiAgICB0aGlzLmxhc3RSZXBvcnQgPSByZXBvcnQ7XG4gICAgcmV0dXJuIHJlcG9ydC5pc1ZhbGlkKCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IHNjaGVtYVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5aU2NoZW1hLnByb3RvdHlwZS52YWxpZGF0ZVNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpICYmIHNjaGVtYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiLnZhbGlkYXRlU2NoZW1hIHdhcyBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhcnJheVwiKTtcbiAgICB9XG5cbiAgICB2YXIgcmVwb3J0ID0gbmV3IFJlcG9ydCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgc2NoZW1hID0gU2NoZW1hQ2FjaGUuZ2V0U2NoZW1hLmNhbGwodGhpcywgcmVwb3J0LCBzY2hlbWEpO1xuXG4gICAgdmFyIGNvbXBpbGVkID0gU2NoZW1hQ29tcGlsYXRpb24uY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcbiAgICBpZiAoY29tcGlsZWQpIHsgU2NoZW1hVmFsaWRhdGlvbi52YWxpZGF0ZVNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTsgfVxuXG4gICAgdGhpcy5sYXN0UmVwb3J0ID0gcmVwb3J0O1xuICAgIHJldHVybiByZXBvcnQuaXNWYWxpZCgpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBqc29uXG4gKiBAcGFyYW0geyp9IHNjaGVtYVxuICogQHBhcmFtIHsqfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKil9IFtjYWxsYmFja11cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuWlNjaGVtYS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoanNvbiwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKFV0aWxzLndoYXRJcyhvcHRpb25zKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG5cbiAgICB0aGlzLnZhbGlkYXRlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB2YXIgd2hhdElzID0gVXRpbHMud2hhdElzKHNjaGVtYSk7XG4gICAgaWYgKHdoYXRJcyAhPT0gXCJzdHJpbmdcIiAmJiB3aGF0SXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIC52YWxpZGF0ZSBjYWxsIC0gc2NoZW1hIG11c3QgYmUgYSBzdHJpbmcgb3Igb2JqZWN0IGJ1dCBcIiArIHdoYXRJcyArIFwiIHdhcyBwYXNzZWQhXCIpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgcmVwb3J0ID0gbmV3IFJlcG9ydCh0aGlzLm9wdGlvbnMpO1xuICAgIHJlcG9ydC5qc29uID0ganNvbjtcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBzY2hlbWFOYW1lID0gc2NoZW1hO1xuICAgICAgICBzY2hlbWEgPSBTY2hlbWFDYWNoZS5nZXRTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYU5hbWUpO1xuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIHdpdGggaWQgJ1wiICsgc2NoZW1hTmFtZSArIFwiJyB3YXNuJ3QgZm91bmQgaW4gdGhlIHZhbGlkYXRvciBjYWNoZSFcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBTY2hlbWFDYWNoZS5nZXRTY2hlbWEuY2FsbCh0aGlzLCByZXBvcnQsIHNjaGVtYSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0gZmFsc2U7XG4gICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGNvbXBpbGVkID0gU2NoZW1hQ29tcGlsYXRpb24uY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgICB0aGlzLmxhc3RSZXBvcnQgPSByZXBvcnQ7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB2YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgdmFsaWRhdGVkID0gU2NoZW1hVmFsaWRhdGlvbi52YWxpZGF0ZVNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ID0gcmVwb3J0O1xuICAgICAgICBmb3VuZEVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWFQYXRoKSB7XG4gICAgICAgIHJlcG9ydC5yb290U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBzY2hlbWEgPSBnZXQoc2NoZW1hLCBvcHRpb25zLnNjaGVtYVBhdGgpO1xuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIHBhdGggJ1wiICsgb3B0aW9ucy5zY2hlbWFQYXRoICsgXCInIHdhc24ndCBmb3VuZCBpbiB0aGUgc2NoZW1hIVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm91bmRFcnJvcikge1xuICAgICAgICBKc29uVmFsaWRhdGlvbi52YWxpZGF0ZS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hLCBqc29uKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmVwb3J0LnByb2Nlc3NBc3luY1Rhc2tzKHRoaXMub3B0aW9ucy5hc3luY1RpbWVvdXQsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocmVwb3J0LmFzeW5jVGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHZhbGlkYXRpb24gaGFzIGFzeW5jIHRhc2tzIGFuZCBjYW5ub3QgYmUgZG9uZSBpbiBzeW5jIG1vZGUsIHBsZWFzZSBwcm92aWRlIGNhbGxiYWNrIGFyZ3VtZW50LlwiKTtcbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gbGFzdFJlcG9ydCBzbyBlcnJvcnMgYXJlIHJldHJpZXZhYmxlIGluIHN5bmMgbW9kZVxuICAgIHRoaXMubGFzdFJlcG9ydCA9IHJlcG9ydDtcbiAgICByZXR1cm4gcmVwb3J0LmlzVmFsaWQoKTtcbn07XG5aU2NoZW1hLnByb3RvdHlwZS5nZXRMYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubGFzdFJlcG9ydC5lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICAgIGUubmFtZSA9IFwiei1zY2hlbWEgdmFsaWRhdGlvbiBlcnJvclwiO1xuICAgIGUubWVzc2FnZSA9IHRoaXMubGFzdFJlcG9ydC5jb21tb25FcnJvck1lc3NhZ2U7XG4gICAgZS5kZXRhaWxzID0gdGhpcy5sYXN0UmVwb3J0LmVycm9ycztcbiAgICByZXR1cm4gZTtcbn07XG5aU2NoZW1hLnByb3RvdHlwZS5nZXRMYXN0RXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RSZXBvcnQgJiYgdGhpcy5sYXN0UmVwb3J0LmVycm9ycy5sZW5ndGggPiAwID8gdGhpcy5sYXN0UmVwb3J0LmVycm9ycyA6IG51bGw7XG59O1xuWlNjaGVtYS5wcm90b3R5cGUuZ2V0TWlzc2luZ1JlZmVyZW5jZXMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgYXJyID0gYXJyIHx8IHRoaXMubGFzdFJlcG9ydC5lcnJvcnM7XG4gICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICBpZHggPSBhcnIubGVuZ3RoO1xuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBhcnJbaWR4XTtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiVU5SRVNPTFZBQkxFX1JFRkVSRU5DRVwiKSB7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlID0gZXJyb3IucGFyYW1zWzBdO1xuICAgICAgICAgICAgaWYgKHJlcy5pbmRleE9mKHJlZmVyZW5jZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IuaW5uZXIpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQodGhpcy5nZXRNaXNzaW5nUmVmZXJlbmNlcyhlcnJvci5pbm5lcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuWlNjaGVtYS5wcm90b3R5cGUuZ2V0TWlzc2luZ1JlbW90ZVJlZmVyZW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pc3NpbmdSZWZlcmVuY2VzID0gdGhpcy5nZXRNaXNzaW5nUmVmZXJlbmNlcygpLFxuICAgICAgICBtaXNzaW5nUmVtb3RlUmVmZXJlbmNlcyA9IFtdLFxuICAgICAgICBpZHggPSBtaXNzaW5nUmVmZXJlbmNlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICAgIHZhciByZW1vdGVSZWZlcmVuY2UgPSBTY2hlbWFDYWNoZS5nZXRSZW1vdGVQYXRoKG1pc3NpbmdSZWZlcmVuY2VzW2lkeF0pO1xuICAgICAgICBpZiAocmVtb3RlUmVmZXJlbmNlICYmIG1pc3NpbmdSZW1vdGVSZWZlcmVuY2VzLmluZGV4T2YocmVtb3RlUmVmZXJlbmNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG1pc3NpbmdSZW1vdGVSZWZlcmVuY2VzLnB1c2gocmVtb3RlUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWlzc2luZ1JlbW90ZVJlZmVyZW5jZXM7XG59O1xuWlNjaGVtYS5wcm90b3R5cGUuc2V0UmVtb3RlUmVmZXJlbmNlID0gZnVuY3Rpb24gKHVyaSwgc2NoZW1hLCB2YWxpZGF0aW9uT3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNjaGVtYSA9IEpTT04ucGFyc2Uoc2NoZW1hKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBVdGlscy5jbG9uZURlZXAoc2NoZW1hKTtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgc2NoZW1hLl9fJHZhbGlkYXRpb25PcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyh2YWxpZGF0aW9uT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgU2NoZW1hQ2FjaGUuY2FjaGVTY2hlbWFCeVVyaS5jYWxsKHRoaXMsIHVyaSwgc2NoZW1hKTtcbn07XG5aU2NoZW1hLnByb3RvdHlwZS5nZXRSZXNvbHZlZFNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICB2YXIgcmVwb3J0ID0gbmV3IFJlcG9ydCh0aGlzLm9wdGlvbnMpO1xuICAgIHNjaGVtYSA9IFNjaGVtYUNhY2hlLmdldFNjaGVtYS5jYWxsKHRoaXMsIHJlcG9ydCwgc2NoZW1hKTtcblxuICAgIC8vIGNsb25lIGJlZm9yZSBtYWtpbmcgYW55IG1vZGlmaWNhdGlvbnNcbiAgICBzY2hlbWEgPSBVdGlscy5jbG9uZURlZXAoc2NoZW1hKTtcblxuICAgIHZhciB2aXNpdGVkID0gW107XG5cbiAgICAvLyBjbGVhbi11cCB0aGUgc2NoZW1hIGFuZCByZXNvbHZlIHJlZmVyZW5jZXNcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIHR5cGVPZiA9IFV0aWxzLndoYXRJcyhzY2hlbWEpO1xuICAgICAgICBpZiAodHlwZU9mICE9PSBcIm9iamVjdFwiICYmIHR5cGVPZiAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLl9fXyR2aXNpdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEuX19fJHZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICB2aXNpdGVkLnB1c2goc2NoZW1hKTtcblxuICAgICAgICBpZiAoc2NoZW1hLiRyZWYgJiYgc2NoZW1hLl9fJHJlZlJlc29sdmVkKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHNjaGVtYS5fXyRyZWZSZXNvbHZlZDtcbiAgICAgICAgICAgIHZhciB0byA9IHNjaGVtYTtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuJHJlZjtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuX18kcmVmUmVzb2x2ZWQ7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihcIl9fJFwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cChzY2hlbWFba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNsZWFudXAoc2NoZW1hKTtcbiAgICB2aXNpdGVkLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgZGVsZXRlIHMuX19fJHZpc2l0ZWQ7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhc3RSZXBvcnQgPSByZXBvcnQ7XG4gICAgaWYgKHJlcG9ydC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLmdldExhc3RFcnJvcigpO1xuICAgIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gc2NoZW1hUmVhZGVyXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblpTY2hlbWEucHJvdG90eXBlLnNldFNjaGVtYVJlYWRlciA9IGZ1bmN0aW9uIChzY2hlbWFSZWFkZXIpIHtcbiAgICByZXR1cm4gWlNjaGVtYS5zZXRTY2hlbWFSZWFkZXIoc2NoZW1hUmVhZGVyKTtcbn07XG5cblpTY2hlbWEucHJvdG90eXBlLmdldFNjaGVtYVJlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWlNjaGVtYS5zY2hlbWFSZWFkZXI7XG59O1xuXG5aU2NoZW1hLnNjaGVtYVJlYWRlciA9IHVuZGVmaW5lZDtcbi8qXG4gICAgc3RhdGljIG1ldGhvZHNcbiovXG5aU2NoZW1hLnNldFNjaGVtYVJlYWRlciA9IGZ1bmN0aW9uIChzY2hlbWFSZWFkZXIpIHtcbiAgICBaU2NoZW1hLnNjaGVtYVJlYWRlciA9IHNjaGVtYVJlYWRlcjtcbn07XG5aU2NoZW1hLnJlZ2lzdGVyRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdE5hbWUsIHZhbGlkYXRvckZ1bmN0aW9uKSB7XG4gICAgRm9ybWF0VmFsaWRhdG9yc1tmb3JtYXROYW1lXSA9IHZhbGlkYXRvckZ1bmN0aW9uO1xufTtcblpTY2hlbWEudW5yZWdpc3RlckZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXROYW1lKSB7XG4gICAgZGVsZXRlIEZvcm1hdFZhbGlkYXRvcnNbZm9ybWF0TmFtZV07XG59O1xuWlNjaGVtYS5nZXRSZWdpc3RlcmVkRm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoRm9ybWF0VmFsaWRhdG9ycyk7XG59O1xuWlNjaGVtYS5nZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVXRpbHMuY2xvbmVEZWVwKGRlZmF1bHRPcHRpb25zKTtcbn07XG5cblpTY2hlbWEuc2NoZW1hU3ltYm9sID0gVXRpbHMuc2NoZW1hU3ltYm9sO1xuXG5aU2NoZW1hLmpzb25TeW1ib2wgPSBVdGlscy5qc29uU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFpTY2hlbWE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/z-schema/src/ZSchema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/schemas/hyper-schema.json":
/*!*************************************************************!*\
  !*** ./node_modules/z-schema/src/schemas/hyper-schema.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"http://json-schema.org/draft-04/hyper-schema#","id":"http://json-schema.org/draft-04/hyper-schema#","title":"JSON Hyper-Schema","allOf":[{"$ref":"http://json-schema.org/draft-04/schema#"}],"properties":{"additionalItems":{"anyOf":[{"type":"boolean"},{"$ref":"#"}]},"additionalProperties":{"anyOf":[{"type":"boolean"},{"$ref":"#"}]},"dependencies":{"additionalProperties":{"anyOf":[{"$ref":"#"},{"type":"array"}]}},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}]},"definitions":{"additionalProperties":{"$ref":"#"}},"patternProperties":{"additionalProperties":{"$ref":"#"}},"properties":{"additionalProperties":{"$ref":"#"}},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"},"links":{"type":"array","items":{"$ref":"#/definitions/linkDescription"}},"fragmentResolution":{"type":"string"},"media":{"type":"object","properties":{"type":{"description":"A media type, as described in RFC 2046","type":"string"},"binaryEncoding":{"description":"A content encoding scheme, as described in RFC 2045","type":"string"}}},"pathStart":{"description":"Instances\' URIs must start with this value for this schema to apply to them","type":"string","format":"uri"}},"definitions":{"schemaArray":{"type":"array","items":{"$ref":"#"}},"linkDescription":{"title":"Link Description Object","type":"object","required":["href","rel"],"properties":{"href":{"description":"a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing","type":"string"},"rel":{"description":"relation to the target resource of the link","type":"string"},"title":{"description":"a title for the link","type":"string"},"targetSchema":{"description":"JSON Schema describing the link target","$ref":"#"},"mediaType":{"description":"media type (as defined by RFC 2046) describing the link target","type":"string"},"method":{"description":"method for requesting the target of the link (e.g. for HTTP this might be \\"GET\\" or \\"DELETE\\")","type":"string"},"encType":{"description":"The media type in which to submit data along with the request","type":"string","default":"application/json"},"schema":{"description":"Schema describing the data to submit along with the request","$ref":"#"}}}}}');

/***/ }),

/***/ "(rsc)/./node_modules/z-schema/src/schemas/schema.json":
/*!*******************************************************!*\
  !*** ./node_modules/z-schema/src/schemas/schema.json ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"http://json-schema.org/draft-04/schema#","$schema":"http://json-schema.org/draft-04/schema#","description":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"positiveInteger":{"type":"integer","minimum":0},"positiveIntegerDefault0":{"allOf":[{"$ref":"#/definitions/positiveInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"minItems":1,"uniqueItems":true}},"type":"object","properties":{"id":{"type":"string","format":"uri"},"$schema":{"type":"string","format":"uri"},"title":{"type":"string"},"description":{"type":"string"},"default":{},"multipleOf":{"type":"number","minimum":0,"exclusiveMinimum":true},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"boolean","default":false},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"boolean","default":false},"maxLength":{"$ref":"#/definitions/positiveInteger"},"minLength":{"$ref":"#/definitions/positiveIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"anyOf":[{"type":"boolean"},{"$ref":"#"}],"default":{}},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":{}},"maxItems":{"$ref":"#/definitions/positiveInteger"},"minItems":{"$ref":"#/definitions/positiveIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"maxProperties":{"$ref":"#/definitions/positiveInteger"},"minProperties":{"$ref":"#/definitions/positiveIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"anyOf":[{"type":"boolean"},{"$ref":"#"}],"default":{}},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"enum":{"type":"array","minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"dependencies":{"exclusiveMaximum":["maximum"],"exclusiveMinimum":["minimum"]},"default":{}}');

/***/ })

};
;