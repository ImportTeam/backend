/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swagger-jsdoc";
exports.ids = ["vendor-chunks/swagger-jsdoc"];
exports.modules = {

/***/ "(rsc)/./node_modules/swagger-jsdoc/index.js":
/*!*********************************************!*\
  !*** ./node_modules/swagger-jsdoc/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./src/lib */ \"(rsc)/./node_modules/swagger-jsdoc/src/lib.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzR0FBcUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSGFyeXU1NDEyXFxEZXNrdG9wXFxTY2hvb2xcXGNhcHN0b25lXFxwaWNzZWxcXGJhY2tlbmRcXG5vZGVfbW9kdWxlc1xcc3dhZ2dlci1qc2RvY1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9saWInKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/swagger-jsdoc/src/lib.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { build } = __webpack_require__(/*! ./specification */ \"(rsc)/./node_modules/swagger-jsdoc/src/specification.js\");\n\n/**\n * Generates the specification.\n * @param {object} options - Configuration options\n * @param {string} options.encoding Optional, passed to readFileSync options. Defaults to 'utf8'.\n * @param {boolean} options.failOnErrors Whether or not to throw when parsing errors. Defaults to false.\n * @param {boolean} options.verbose Whether the swagger snippet containing each error should be included in print/throws. Defaults to false.\n * @param {string} options.format Optional, defaults to '.json' - target file format '.yml' or '.yaml'.\n * @param {object} options.swaggerDefinition\n * @param {object} options.definition\n * @param {array} options.apis\n * @returns {object} Output specification\n */\nmodule.exports = (options) => {\n  if (!options) {\n    throw new Error(`Missing or invalid input: 'options' is required`);\n  }\n\n  if (!options.swaggerDefinition && !options.definition) {\n    throw new Error(\n      `Missing or invalid input: 'options.swaggerDefinition' or 'options.definition' is required`\n    );\n  }\n\n  if (!options.apis || !Array.isArray(options.apis)) {\n    throw new Error(\n      `Missing or invalid input: 'options.apis' is required and it should be an array.`\n    );\n  }\n\n  return build(options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsZ0ZBQWlCOztBQUUzQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFxzd2FnZ2VyLWpzZG9jXFxzcmNcXGxpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGJ1aWxkIH0gPSByZXF1aXJlKCcuL3NwZWNpZmljYXRpb24nKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIHNwZWNpZmljYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZW5jb2RpbmcgT3B0aW9uYWwsIHBhc3NlZCB0byByZWFkRmlsZVN5bmMgb3B0aW9ucy4gRGVmYXVsdHMgdG8gJ3V0ZjgnLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmZhaWxPbkVycm9ycyBXaGV0aGVyIG9yIG5vdCB0byB0aHJvdyB3aGVuIHBhcnNpbmcgZXJyb3JzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy52ZXJib3NlIFdoZXRoZXIgdGhlIHN3YWdnZXIgc25pcHBldCBjb250YWluaW5nIGVhY2ggZXJyb3Igc2hvdWxkIGJlIGluY2x1ZGVkIGluIHByaW50L3Rocm93cy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mb3JtYXQgT3B0aW9uYWwsIGRlZmF1bHRzIHRvICcuanNvbicgLSB0YXJnZXQgZmlsZSBmb3JtYXQgJy55bWwnIG9yICcueWFtbCcuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zd2FnZ2VyRGVmaW5pdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuZGVmaW5pdGlvblxuICogQHBhcmFtIHthcnJheX0gb3B0aW9ucy5hcGlzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBPdXRwdXQgc3BlY2lmaWNhdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRpb25zKSA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBvciBpbnZhbGlkIGlucHV0OiAnb3B0aW9ucycgaXMgcmVxdWlyZWRgKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5zd2FnZ2VyRGVmaW5pdGlvbiAmJiAhb3B0aW9ucy5kZWZpbml0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE1pc3Npbmcgb3IgaW52YWxpZCBpbnB1dDogJ29wdGlvbnMuc3dhZ2dlckRlZmluaXRpb24nIG9yICdvcHRpb25zLmRlZmluaXRpb24nIGlzIHJlcXVpcmVkYFxuICAgICk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuYXBpcyB8fCAhQXJyYXkuaXNBcnJheShvcHRpb25zLmFwaXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE1pc3Npbmcgb3IgaW52YWxpZCBpbnB1dDogJ29wdGlvbnMuYXBpcycgaXMgcmVxdWlyZWQgYW5kIGl0IHNob3VsZCBiZSBhbiBhcnJheS5gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZChvcHRpb25zKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/src/lib.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/src/specification.js":
/*!*********************************************************!*\
  !*** ./node_modules/swagger-jsdoc/src/specification.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const doctrine = __webpack_require__(/*! doctrine */ \"(rsc)/./node_modules/doctrine/lib/doctrine.js\");\nconst parser = __webpack_require__(/*! swagger-parser */ \"(rsc)/./node_modules/swagger-parser/index.js\");\nconst YAML = __webpack_require__(/*! yaml */ \"(rsc)/./node_modules/yaml/index.js\");\n\nconst {\n  hasEmptyProperty,\n  convertGlobPaths,\n  extractAnnotations,\n  mergeDeep,\n  extractYamlFromJsDoc,\n  isTagPresentInTags,\n} = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/swagger-jsdoc/src/utils.js\");\n\n/**\n * Prepare the swagger/openapi specification object.\n * @see https://github.com/OAI/OpenAPI-Specification/tree/master/versions\n * @param {object} definition - The `definition` or `swaggerDefinition` from options.\n * @returns {object} swaggerObject\n */\nfunction prepare(definition) {\n  const swaggerObject = JSON.parse(JSON.stringify(definition));\n  const specificationTemplate = {\n    v2: [\n      'paths',\n      'definitions',\n      'responses',\n      'parameters',\n      'securityDefinitions',\n    ],\n    v3: [\n      'paths',\n      'definitions',\n      'responses',\n      'parameters',\n      'securityDefinitions',\n      'components',\n    ],\n    v4: ['components', 'channels'],\n  };\n\n  const getVersion = () => {\n    if (swaggerObject.asyncapi) {\n      return 'v4';\n    }\n\n    if (swaggerObject.openapi) {\n      return 'v3';\n    }\n\n    if (swaggerObject.swagger) {\n      return 'v2';\n    }\n\n    swaggerObject.swagger = '2.0';\n    return 'v2';\n  };\n\n  const version = getVersion();\n\n  specificationTemplate[version].forEach((property) => {\n    swaggerObject[property] = swaggerObject[property] || {};\n  });\n\n  swaggerObject.tags = swaggerObject.tags || [];\n\n  return swaggerObject;\n}\n\n/**\n * @param {object} obj\n * @param {string} ext\n */\nfunction format(swaggerObject, ext) {\n  if (ext === '.yml' || ext === '.yaml') {\n    return YAML.stringify(swaggerObject);\n  }\n  return swaggerObject;\n}\n\n/**\n * OpenAPI specification validator does not accept empty values for a few properties.\n * Solves validator error: \"Schema error should NOT have additional properties\"\n * @param {object} swaggerObject\n * @returns {object} swaggerObject\n */\nfunction clean(swaggerObject) {\n  for (const prop of [\n    'definitions',\n    'responses',\n    'parameters',\n    'securityDefinitions',\n  ]) {\n    if (hasEmptyProperty(swaggerObject[prop])) {\n      delete swaggerObject[prop];\n    }\n  }\n\n  return swaggerObject;\n}\n\n/**\n * Parse the swagger object and remove useless properties if necessary.\n *\n * @param {object} swaggerObject - Swagger object from parsing the api files.\n * @returns {object} The specification.\n */\nfunction finalize(swaggerObject, options) {\n  let specification = swaggerObject;\n  parser.parse(swaggerObject, (err, api) => {\n    if (!err) {\n      specification = api;\n    }\n  });\n\n  if (specification.openapi) {\n    specification = clean(specification);\n  }\n\n  return format(specification, options.format);\n}\n\n/**\n * @param {object} swaggerObject\n * @param {object} annotation\n * @param {string} property\n */\nfunction organize(swaggerObject, annotation, property) {\n  // Root property on purpose.\n  // @see https://github.com/OAI/OpenAPI-Specification/blob/master/proposals/002_Webhooks.md#proposed-solution\n  if (property === 'x-webhooks') {\n    swaggerObject[property] = mergeDeep(\n      swaggerObject[property],\n      annotation[property]\n    );\n  }\n\n  // Other extensions can be in varying places depending on different vendors and opinions.\n  // The following return makes it so that they are not put in `paths` in the last case.\n  // New specific extensions will need to be handled on case-by-case if to be included in `paths`.\n  if (property.startsWith('x-')) return;\n\n  const commonProperties = [\n    'components',\n    'consumes',\n    'produces',\n    'paths',\n    'schemas',\n    'securityDefinitions',\n    'responses',\n    'parameters',\n    'definitions',\n    'channels',\n  ];\n  if (commonProperties.includes(property)) {\n    for (const definition of Object.keys(annotation[property])) {\n      swaggerObject[property][definition] = mergeDeep(\n        swaggerObject[property][definition],\n        annotation[property][definition]\n      );\n    }\n  } else if (property === 'tags') {\n    const { tags } = annotation;\n\n    if (Array.isArray(tags)) {\n      for (const tag of tags) {\n        if (!isTagPresentInTags(tag, swaggerObject.tags)) {\n          swaggerObject.tags.push(tag);\n        }\n      }\n    } else if (!isTagPresentInTags(tags, swaggerObject.tags)) {\n      swaggerObject.tags.push(tags);\n    }\n  } else {\n    // Paths which are not defined as \"paths\" property, starting with a slash \"/\"\n    swaggerObject.paths[property] = mergeDeep(\n      swaggerObject.paths[property],\n      annotation[property]\n    );\n  }\n}\n\n/**\n * @param {object} options\n * @returns {object} swaggerObject\n */\nfunction build(options) {\n  YAML.defaultOptions.keepCstNodes = true;\n\n  // Get input definition and prepare the specification's skeleton\n  const definition = options.swaggerDefinition || options.definition;\n  const specification = prepare(definition);\n  const yamlDocsAnchors = new Map();\n  const yamlDocsErrors = [];\n  const yamlDocsReady = [];\n\n  for (const filePath of convertGlobPaths(options.apis)) {\n    const {\n      yaml: yamlAnnotations,\n      jsdoc: jsdocAnnotations,\n    } = extractAnnotations(filePath, options.encoding);\n\n    if (yamlAnnotations.length) {\n      for (const annotation of yamlAnnotations) {\n        const parsed = Object.assign(YAML.parseDocument(annotation), {\n          filePath,\n        });\n\n        const anchors = parsed.anchors.getNames();\n        if (anchors.length) {\n          for (const anchor of anchors) {\n            yamlDocsAnchors.set(anchor, parsed);\n          }\n        } else if (parsed.errors && parsed.errors.length) {\n          // Attach the relevent yaml section to the error for verbose logging\n          parsed.errors.forEach((err) => {\n            err.annotation = annotation;\n          });\n          yamlDocsErrors.push(parsed);\n        } else {\n          yamlDocsReady.push(parsed);\n        }\n      }\n    }\n\n    if (jsdocAnnotations.length) {\n      for (const annotation of jsdocAnnotations) {\n        const jsDocComment = doctrine.parse(annotation, { unwrap: true });\n        for (const doc of extractYamlFromJsDoc(jsDocComment)) {\n          const parsed = Object.assign(YAML.parseDocument(doc), { filePath });\n\n          const anchors = parsed.anchors.getNames();\n          if (anchors.length) {\n            for (const anchor of anchors) {\n              yamlDocsAnchors.set(anchor, parsed);\n            }\n          } else if (parsed.errors && parsed.errors.length) {\n            // Attach the relevent yaml section to the error for verbose logging\n            parsed.errors.forEach((err) => {\n              err.annotation = doc;\n            });\n            yamlDocsErrors.push(parsed);\n          } else {\n            yamlDocsReady.push(parsed);\n          }\n        }\n      }\n    }\n  }\n\n  if (yamlDocsErrors.length) {\n    for (const docWithErr of yamlDocsErrors) {\n      const errsToDelete = [];\n      docWithErr.errors.forEach((error, index) => {\n        if (error.name === 'YAMLReferenceError') {\n          // This should either be a smart regex or ideally a YAML library method using the error.range.\n          // The following works with both pretty and not pretty errors.\n          const refErr = error.message\n            .split('Aliased anchor not found: ')\n            .filter((a) => a)\n            .join('')\n            .split(' at line')[0];\n          const anchor = yamlDocsAnchors.get(refErr);\n          const anchorString = anchor.cstNode.toString();\n          const originalString = docWithErr.cstNode.toString();\n          const readyDocument = YAML.parseDocument(\n            `${anchorString}\\n${originalString}`\n          );\n\n          yamlDocsReady.push(readyDocument);\n          errsToDelete.push(index);\n        }\n      });\n      // reverse sort the deletion array so we always delete from the end\n      errsToDelete.sort((a, b) => b - a);\n\n      // Cleanup solved errors in order to allow for parser to pass through.\n      for (const errIndex of errsToDelete) {\n        docWithErr.errors.splice(errIndex, 1);\n      }\n    }\n\n    // Format errors into a printable/throwable string\n    const errReport = yamlDocsErrors\n      .filter((doc) => doc.errors.length)\n      .map(({ errors, filePath }) => {\n        let str = `Error in ${filePath} :\\n`;\n        if (options.verbose) {\n          str += errors\n            .map(\n              (e) =>\n                `${e.toString()}\\nImbedded within:\\n\\`\\`\\`\\n  ${e.annotation.replace(\n                  /\\n/g,\n                  '\\n  '\n                )}\\n\\`\\`\\``\n            )\n            .join('\\n');\n        } else {\n          str += errors.map((e) => e.toString()).join('\\n');\n        }\n        return str;\n      })\n      .filter((error) => !!error);\n\n    if (errReport.length) {\n      if (options.failOnErrors) {\n        throw new Error(errReport);\n      }\n      // Place to provide feedback for errors. Previously throwing, now reporting only.\n      console.info(\n        'Not all input has been taken into account at your final specification.'\n      );\n\n      console.error(`Here's the report: \\n\\n\\n ${errReport}`);\n    }\n  }\n\n  for (const document of yamlDocsReady) {\n    const parsedDoc = document.toJSON();\n    for (const property in parsedDoc) {\n      organize(specification, parsedDoc, property);\n    }\n  }\n\n  return finalize(specification, options);\n}\n\nmodule.exports = { prepare, build, organize, finalize, format };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvc3BlY2lmaWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQywrREFBVTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxnREFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxnRUFBUzs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVksT0FBTzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQSxrRUFBa0UsVUFBVTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhLElBQUksZUFBZTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFxzd2FnZ2VyLWpzZG9jXFxzcmNcXHNwZWNpZmljYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZG9jdHJpbmUgPSByZXF1aXJlKCdkb2N0cmluZScpO1xuY29uc3QgcGFyc2VyID0gcmVxdWlyZSgnc3dhZ2dlci1wYXJzZXInKTtcbmNvbnN0IFlBTUwgPSByZXF1aXJlKCd5YW1sJyk7XG5cbmNvbnN0IHtcbiAgaGFzRW1wdHlQcm9wZXJ0eSxcbiAgY29udmVydEdsb2JQYXRocyxcbiAgZXh0cmFjdEFubm90YXRpb25zLFxuICBtZXJnZURlZXAsXG4gIGV4dHJhY3RZYW1sRnJvbUpzRG9jLFxuICBpc1RhZ1ByZXNlbnRJblRhZ3MsXG59ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN3YWdnZXIvb3BlbmFwaSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL09BSS9PcGVuQVBJLVNwZWNpZmljYXRpb24vdHJlZS9tYXN0ZXIvdmVyc2lvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZpbml0aW9uIC0gVGhlIGBkZWZpbml0aW9uYCBvciBgc3dhZ2dlckRlZmluaXRpb25gIGZyb20gb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IHN3YWdnZXJPYmplY3RcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZShkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHN3YWdnZXJPYmplY3QgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmluaXRpb24pKTtcbiAgY29uc3Qgc3BlY2lmaWNhdGlvblRlbXBsYXRlID0ge1xuICAgIHYyOiBbXG4gICAgICAncGF0aHMnLFxuICAgICAgJ2RlZmluaXRpb25zJyxcbiAgICAgICdyZXNwb25zZXMnLFxuICAgICAgJ3BhcmFtZXRlcnMnLFxuICAgICAgJ3NlY3VyaXR5RGVmaW5pdGlvbnMnLFxuICAgIF0sXG4gICAgdjM6IFtcbiAgICAgICdwYXRocycsXG4gICAgICAnZGVmaW5pdGlvbnMnLFxuICAgICAgJ3Jlc3BvbnNlcycsXG4gICAgICAncGFyYW1ldGVycycsXG4gICAgICAnc2VjdXJpdHlEZWZpbml0aW9ucycsXG4gICAgICAnY29tcG9uZW50cycsXG4gICAgXSxcbiAgICB2NDogWydjb21wb25lbnRzJywgJ2NoYW5uZWxzJ10sXG4gIH07XG5cbiAgY29uc3QgZ2V0VmVyc2lvbiA9ICgpID0+IHtcbiAgICBpZiAoc3dhZ2dlck9iamVjdC5hc3luY2FwaSkge1xuICAgICAgcmV0dXJuICd2NCc7XG4gICAgfVxuXG4gICAgaWYgKHN3YWdnZXJPYmplY3Qub3BlbmFwaSkge1xuICAgICAgcmV0dXJuICd2Myc7XG4gICAgfVxuXG4gICAgaWYgKHN3YWdnZXJPYmplY3Quc3dhZ2dlcikge1xuICAgICAgcmV0dXJuICd2Mic7XG4gICAgfVxuXG4gICAgc3dhZ2dlck9iamVjdC5zd2FnZ2VyID0gJzIuMCc7XG4gICAgcmV0dXJuICd2Mic7XG4gIH07XG5cbiAgY29uc3QgdmVyc2lvbiA9IGdldFZlcnNpb24oKTtcblxuICBzcGVjaWZpY2F0aW9uVGVtcGxhdGVbdmVyc2lvbl0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICBzd2FnZ2VyT2JqZWN0W3Byb3BlcnR5XSA9IHN3YWdnZXJPYmplY3RbcHJvcGVydHldIHx8IHt9O1xuICB9KTtcblxuICBzd2FnZ2VyT2JqZWN0LnRhZ3MgPSBzd2FnZ2VyT2JqZWN0LnRhZ3MgfHwgW107XG5cbiAgcmV0dXJuIHN3YWdnZXJPYmplY3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IGV4dFxuICovXG5mdW5jdGlvbiBmb3JtYXQoc3dhZ2dlck9iamVjdCwgZXh0KSB7XG4gIGlmIChleHQgPT09ICcueW1sJyB8fCBleHQgPT09ICcueWFtbCcpIHtcbiAgICByZXR1cm4gWUFNTC5zdHJpbmdpZnkoc3dhZ2dlck9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHN3YWdnZXJPYmplY3Q7XG59XG5cbi8qKlxuICogT3BlbkFQSSBzcGVjaWZpY2F0aW9uIHZhbGlkYXRvciBkb2VzIG5vdCBhY2NlcHQgZW1wdHkgdmFsdWVzIGZvciBhIGZldyBwcm9wZXJ0aWVzLlxuICogU29sdmVzIHZhbGlkYXRvciBlcnJvcjogXCJTY2hlbWEgZXJyb3Igc2hvdWxkIE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiXG4gKiBAcGFyYW0ge29iamVjdH0gc3dhZ2dlck9iamVjdFxuICogQHJldHVybnMge29iamVjdH0gc3dhZ2dlck9iamVjdFxuICovXG5mdW5jdGlvbiBjbGVhbihzd2FnZ2VyT2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBbXG4gICAgJ2RlZmluaXRpb25zJyxcbiAgICAncmVzcG9uc2VzJyxcbiAgICAncGFyYW1ldGVycycsXG4gICAgJ3NlY3VyaXR5RGVmaW5pdGlvbnMnLFxuICBdKSB7XG4gICAgaWYgKGhhc0VtcHR5UHJvcGVydHkoc3dhZ2dlck9iamVjdFtwcm9wXSkpIHtcbiAgICAgIGRlbGV0ZSBzd2FnZ2VyT2JqZWN0W3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzd2FnZ2VyT2JqZWN0O1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBzd2FnZ2VyIG9iamVjdCBhbmQgcmVtb3ZlIHVzZWxlc3MgcHJvcGVydGllcyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN3YWdnZXJPYmplY3QgLSBTd2FnZ2VyIG9iamVjdCBmcm9tIHBhcnNpbmcgdGhlIGFwaSBmaWxlcy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBzcGVjaWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBmaW5hbGl6ZShzd2FnZ2VyT2JqZWN0LCBvcHRpb25zKSB7XG4gIGxldCBzcGVjaWZpY2F0aW9uID0gc3dhZ2dlck9iamVjdDtcbiAgcGFyc2VyLnBhcnNlKHN3YWdnZXJPYmplY3QsIChlcnIsIGFwaSkgPT4ge1xuICAgIGlmICghZXJyKSB7XG4gICAgICBzcGVjaWZpY2F0aW9uID0gYXBpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHNwZWNpZmljYXRpb24ub3BlbmFwaSkge1xuICAgIHNwZWNpZmljYXRpb24gPSBjbGVhbihzcGVjaWZpY2F0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWNhdGlvbiwgb3B0aW9ucy5mb3JtYXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBzd2FnZ2VyT2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gYW5ub3RhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIG9yZ2FuaXplKHN3YWdnZXJPYmplY3QsIGFubm90YXRpb24sIHByb3BlcnR5KSB7XG4gIC8vIFJvb3QgcHJvcGVydHkgb24gcHVycG9zZS5cbiAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vT0FJL09wZW5BUEktU3BlY2lmaWNhdGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDAyX1dlYmhvb2tzLm1kI3Byb3Bvc2VkLXNvbHV0aW9uXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gtd2ViaG9va3MnKSB7XG4gICAgc3dhZ2dlck9iamVjdFtwcm9wZXJ0eV0gPSBtZXJnZURlZXAoXG4gICAgICBzd2FnZ2VyT2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgIGFubm90YXRpb25bcHJvcGVydHldXG4gICAgKTtcbiAgfVxuXG4gIC8vIE90aGVyIGV4dGVuc2lvbnMgY2FuIGJlIGluIHZhcnlpbmcgcGxhY2VzIGRlcGVuZGluZyBvbiBkaWZmZXJlbnQgdmVuZG9ycyBhbmQgb3BpbmlvbnMuXG4gIC8vIFRoZSBmb2xsb3dpbmcgcmV0dXJuIG1ha2VzIGl0IHNvIHRoYXQgdGhleSBhcmUgbm90IHB1dCBpbiBgcGF0aHNgIGluIHRoZSBsYXN0IGNhc2UuXG4gIC8vIE5ldyBzcGVjaWZpYyBleHRlbnNpb25zIHdpbGwgbmVlZCB0byBiZSBoYW5kbGVkIG9uIGNhc2UtYnktY2FzZSBpZiB0byBiZSBpbmNsdWRlZCBpbiBgcGF0aHNgLlxuICBpZiAocHJvcGVydHkuc3RhcnRzV2l0aCgneC0nKSkgcmV0dXJuO1xuXG4gIGNvbnN0IGNvbW1vblByb3BlcnRpZXMgPSBbXG4gICAgJ2NvbXBvbmVudHMnLFxuICAgICdjb25zdW1lcycsXG4gICAgJ3Byb2R1Y2VzJyxcbiAgICAncGF0aHMnLFxuICAgICdzY2hlbWFzJyxcbiAgICAnc2VjdXJpdHlEZWZpbml0aW9ucycsXG4gICAgJ3Jlc3BvbnNlcycsXG4gICAgJ3BhcmFtZXRlcnMnLFxuICAgICdkZWZpbml0aW9ucycsXG4gICAgJ2NoYW5uZWxzJyxcbiAgXTtcbiAgaWYgKGNvbW1vblByb3BlcnRpZXMuaW5jbHVkZXMocHJvcGVydHkpKSB7XG4gICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIE9iamVjdC5rZXlzKGFubm90YXRpb25bcHJvcGVydHldKSkge1xuICAgICAgc3dhZ2dlck9iamVjdFtwcm9wZXJ0eV1bZGVmaW5pdGlvbl0gPSBtZXJnZURlZXAoXG4gICAgICAgIHN3YWdnZXJPYmplY3RbcHJvcGVydHldW2RlZmluaXRpb25dLFxuICAgICAgICBhbm5vdGF0aW9uW3Byb3BlcnR5XVtkZWZpbml0aW9uXVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICd0YWdzJykge1xuICAgIGNvbnN0IHsgdGFncyB9ID0gYW5ub3RhdGlvbjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhZ3MpKSB7XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghaXNUYWdQcmVzZW50SW5UYWdzKHRhZywgc3dhZ2dlck9iamVjdC50YWdzKSkge1xuICAgICAgICAgIHN3YWdnZXJPYmplY3QudGFncy5wdXNoKHRhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1RhZ1ByZXNlbnRJblRhZ3ModGFncywgc3dhZ2dlck9iamVjdC50YWdzKSkge1xuICAgICAgc3dhZ2dlck9iamVjdC50YWdzLnB1c2godGFncyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFBhdGhzIHdoaWNoIGFyZSBub3QgZGVmaW5lZCBhcyBcInBhdGhzXCIgcHJvcGVydHksIHN0YXJ0aW5nIHdpdGggYSBzbGFzaCBcIi9cIlxuICAgIHN3YWdnZXJPYmplY3QucGF0aHNbcHJvcGVydHldID0gbWVyZ2VEZWVwKFxuICAgICAgc3dhZ2dlck9iamVjdC5wYXRoc1twcm9wZXJ0eV0sXG4gICAgICBhbm5vdGF0aW9uW3Byb3BlcnR5XVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge29iamVjdH0gc3dhZ2dlck9iamVjdFxuICovXG5mdW5jdGlvbiBidWlsZChvcHRpb25zKSB7XG4gIFlBTUwuZGVmYXVsdE9wdGlvbnMua2VlcENzdE5vZGVzID0gdHJ1ZTtcblxuICAvLyBHZXQgaW5wdXQgZGVmaW5pdGlvbiBhbmQgcHJlcGFyZSB0aGUgc3BlY2lmaWNhdGlvbidzIHNrZWxldG9uXG4gIGNvbnN0IGRlZmluaXRpb24gPSBvcHRpb25zLnN3YWdnZXJEZWZpbml0aW9uIHx8IG9wdGlvbnMuZGVmaW5pdGlvbjtcbiAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IHByZXBhcmUoZGVmaW5pdGlvbik7XG4gIGNvbnN0IHlhbWxEb2NzQW5jaG9ycyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgeWFtbERvY3NFcnJvcnMgPSBbXTtcbiAgY29uc3QgeWFtbERvY3NSZWFkeSA9IFtdO1xuXG4gIGZvciAoY29uc3QgZmlsZVBhdGggb2YgY29udmVydEdsb2JQYXRocyhvcHRpb25zLmFwaXMpKSB7XG4gICAgY29uc3Qge1xuICAgICAgeWFtbDogeWFtbEFubm90YXRpb25zLFxuICAgICAganNkb2M6IGpzZG9jQW5ub3RhdGlvbnMsXG4gICAgfSA9IGV4dHJhY3RBbm5vdGF0aW9ucyhmaWxlUGF0aCwgb3B0aW9ucy5lbmNvZGluZyk7XG5cbiAgICBpZiAoeWFtbEFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIHlhbWxBbm5vdGF0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBPYmplY3QuYXNzaWduKFlBTUwucGFyc2VEb2N1bWVudChhbm5vdGF0aW9uKSwge1xuICAgICAgICAgIGZpbGVQYXRoLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhbmNob3JzID0gcGFyc2VkLmFuY2hvcnMuZ2V0TmFtZXMoKTtcbiAgICAgICAgaWYgKGFuY2hvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBhbmNob3Igb2YgYW5jaG9ycykge1xuICAgICAgICAgICAgeWFtbERvY3NBbmNob3JzLnNldChhbmNob3IsIHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZC5lcnJvcnMgJiYgcGFyc2VkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBBdHRhY2ggdGhlIHJlbGV2ZW50IHlhbWwgc2VjdGlvbiB0byB0aGUgZXJyb3IgZm9yIHZlcmJvc2UgbG9nZ2luZ1xuICAgICAgICAgIHBhcnNlZC5lcnJvcnMuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBlcnIuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeWFtbERvY3NFcnJvcnMucHVzaChwYXJzZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlhbWxEb2NzUmVhZHkucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGpzZG9jQW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGFubm90YXRpb24gb2YganNkb2NBbm5vdGF0aW9ucykge1xuICAgICAgICBjb25zdCBqc0RvY0NvbW1lbnQgPSBkb2N0cmluZS5wYXJzZShhbm5vdGF0aW9uLCB7IHVud3JhcDogdHJ1ZSB9KTtcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZXh0cmFjdFlhbWxGcm9tSnNEb2MoanNEb2NDb21tZW50KSkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IE9iamVjdC5hc3NpZ24oWUFNTC5wYXJzZURvY3VtZW50KGRvYyksIHsgZmlsZVBhdGggfSk7XG5cbiAgICAgICAgICBjb25zdCBhbmNob3JzID0gcGFyc2VkLmFuY2hvcnMuZ2V0TmFtZXMoKTtcbiAgICAgICAgICBpZiAoYW5jaG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIGFuY2hvcnMpIHtcbiAgICAgICAgICAgICAgeWFtbERvY3NBbmNob3JzLnNldChhbmNob3IsIHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQuZXJyb3JzICYmIHBhcnNlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIHJlbGV2ZW50IHlhbWwgc2VjdGlvbiB0byB0aGUgZXJyb3IgZm9yIHZlcmJvc2UgbG9nZ2luZ1xuICAgICAgICAgICAgcGFyc2VkLmVycm9ycy5mb3JFYWNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgZXJyLmFubm90YXRpb24gPSBkb2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlhbWxEb2NzRXJyb3JzLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWFtbERvY3NSZWFkeS5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHlhbWxEb2NzRXJyb3JzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgZG9jV2l0aEVyciBvZiB5YW1sRG9jc0Vycm9ycykge1xuICAgICAgY29uc3QgZXJyc1RvRGVsZXRlID0gW107XG4gICAgICBkb2NXaXRoRXJyLmVycm9ycy5mb3JFYWNoKChlcnJvciwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdZQU1MUmVmZXJlbmNlRXJyb3InKSB7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgZWl0aGVyIGJlIGEgc21hcnQgcmVnZXggb3IgaWRlYWxseSBhIFlBTUwgbGlicmFyeSBtZXRob2QgdXNpbmcgdGhlIGVycm9yLnJhbmdlLlxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgd29ya3Mgd2l0aCBib3RoIHByZXR0eSBhbmQgbm90IHByZXR0eSBlcnJvcnMuXG4gICAgICAgICAgY29uc3QgcmVmRXJyID0gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgLnNwbGl0KCdBbGlhc2VkIGFuY2hvciBub3QgZm91bmQ6ICcpXG4gICAgICAgICAgICAuZmlsdGVyKChhKSA9PiBhKVxuICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgICAgICAuc3BsaXQoJyBhdCBsaW5lJylbMF07XG4gICAgICAgICAgY29uc3QgYW5jaG9yID0geWFtbERvY3NBbmNob3JzLmdldChyZWZFcnIpO1xuICAgICAgICAgIGNvbnN0IGFuY2hvclN0cmluZyA9IGFuY2hvci5jc3ROb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBkb2NXaXRoRXJyLmNzdE5vZGUudG9TdHJpbmcoKTtcbiAgICAgICAgICBjb25zdCByZWFkeURvY3VtZW50ID0gWUFNTC5wYXJzZURvY3VtZW50KFxuICAgICAgICAgICAgYCR7YW5jaG9yU3RyaW5nfVxcbiR7b3JpZ2luYWxTdHJpbmd9YFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB5YW1sRG9jc1JlYWR5LnB1c2gocmVhZHlEb2N1bWVudCk7XG4gICAgICAgICAgZXJyc1RvRGVsZXRlLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHJldmVyc2Ugc29ydCB0aGUgZGVsZXRpb24gYXJyYXkgc28gd2UgYWx3YXlzIGRlbGV0ZSBmcm9tIHRoZSBlbmRcbiAgICAgIGVycnNUb0RlbGV0ZS5zb3J0KChhLCBiKSA9PiBiIC0gYSk7XG5cbiAgICAgIC8vIENsZWFudXAgc29sdmVkIGVycm9ycyBpbiBvcmRlciB0byBhbGxvdyBmb3IgcGFyc2VyIHRvIHBhc3MgdGhyb3VnaC5cbiAgICAgIGZvciAoY29uc3QgZXJySW5kZXggb2YgZXJyc1RvRGVsZXRlKSB7XG4gICAgICAgIGRvY1dpdGhFcnIuZXJyb3JzLnNwbGljZShlcnJJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGVycm9ycyBpbnRvIGEgcHJpbnRhYmxlL3Rocm93YWJsZSBzdHJpbmdcbiAgICBjb25zdCBlcnJSZXBvcnQgPSB5YW1sRG9jc0Vycm9yc1xuICAgICAgLmZpbHRlcigoZG9jKSA9PiBkb2MuZXJyb3JzLmxlbmd0aClcbiAgICAgIC5tYXAoKHsgZXJyb3JzLCBmaWxlUGF0aCB9KSA9PiB7XG4gICAgICAgIGxldCBzdHIgPSBgRXJyb3IgaW4gJHtmaWxlUGF0aH0gOlxcbmA7XG4gICAgICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgICAgICBzdHIgKz0gZXJyb3JzXG4gICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAoZSkgPT5cbiAgICAgICAgICAgICAgICBgJHtlLnRvU3RyaW5nKCl9XFxuSW1iZWRkZWQgd2l0aGluOlxcblxcYFxcYFxcYFxcbiAgJHtlLmFubm90YXRpb24ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgIC9cXG4vZyxcbiAgICAgICAgICAgICAgICAgICdcXG4gICdcbiAgICAgICAgICAgICAgICApfVxcblxcYFxcYFxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gZXJyb3JzLm1hcCgoZSkgPT4gZS50b1N0cmluZygpKS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKGVycm9yKSA9PiAhIWVycm9yKTtcblxuICAgIGlmIChlcnJSZXBvcnQubGVuZ3RoKSB7XG4gICAgICBpZiAob3B0aW9ucy5mYWlsT25FcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclJlcG9ydCk7XG4gICAgICB9XG4gICAgICAvLyBQbGFjZSB0byBwcm92aWRlIGZlZWRiYWNrIGZvciBlcnJvcnMuIFByZXZpb3VzbHkgdGhyb3dpbmcsIG5vdyByZXBvcnRpbmcgb25seS5cbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgJ05vdCBhbGwgaW5wdXQgaGFzIGJlZW4gdGFrZW4gaW50byBhY2NvdW50IGF0IHlvdXIgZmluYWwgc3BlY2lmaWNhdGlvbi4nXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmVycm9yKGBIZXJlJ3MgdGhlIHJlcG9ydDogXFxuXFxuXFxuICR7ZXJyUmVwb3J0fWApO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgeWFtbERvY3NSZWFkeSkge1xuICAgIGNvbnN0IHBhcnNlZERvYyA9IGRvY3VtZW50LnRvSlNPTigpO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gcGFyc2VkRG9jKSB7XG4gICAgICBvcmdhbml6ZShzcGVjaWZpY2F0aW9uLCBwYXJzZWREb2MsIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxpemUoc3BlY2lmaWNhdGlvbiwgb3B0aW9ucyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwcmVwYXJlLCBidWlsZCwgb3JnYW5pemUsIGZpbmFsaXplLCBmb3JtYXQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/src/specification.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/swagger-jsdoc/src/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/swagger-jsdoc/src/utils.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/glob.js\");\nconst mergeWith = __webpack_require__(/*! lodash.mergewith */ \"(rsc)/./node_modules/lodash.mergewith/index.js\");\n\n/**\n * Converts an array of globs to full paths\n * @param {array} globs - Array of globs and/or normal paths\n * @return {array} Array of fully-qualified paths\n */\nfunction convertGlobPaths(globs) {\n  return globs\n    .map((globString) => glob.sync(globString))\n    .reduce((previous, current) => previous.concat(current), []);\n}\n\n/**\n * Checks if there is any properties of the input object which are an empty object\n * @param {object} obj - the object to check\n * @returns {boolean}\n */\nfunction hasEmptyProperty(obj) {\n  return Object.keys(obj)\n    .map((key) => obj[key])\n    .every(\n      (keyObject) =>\n        typeof keyObject === 'object' &&\n        Object.keys(keyObject).every((key) => !(key in keyObject))\n    );\n}\n\n/**\n * Extracts the YAML description from JSDoc comments with `@swagger`/`@openapi` annotation.\n * @param {object} jsDocComment - Single item of JSDoc comments from doctrine.parse\n * @returns {array} YAML parts\n */\nfunction extractYamlFromJsDoc(jsDocComment) {\n  const yamlParts = [];\n\n  for (const tag of jsDocComment.tags) {\n    if (tag.title === 'swagger' || tag.title === 'openapi') {\n      yamlParts.push(tag.description);\n    }\n  }\n\n  return yamlParts;\n}\n\n/**\n * @param {string} filePath\n * @returns {{jsdoc: array, yaml: array}} JSDoc comments and Yaml files\n */\nfunction extractAnnotations(filePath, encoding = 'utf8') {\n  const fileContent = fs.readFileSync(filePath, { encoding });\n  const ext = path.extname(filePath);\n  const jsDocRegex = /\\/\\*\\*([\\s\\S]*?)\\*\\//gm;\n  const csDocRegex = /###([\\s\\S]*?)###/gm;\n  const yaml = [];\n  const jsdoc = [];\n  let regexResults = null;\n\n  switch (ext) {\n    case '.yml':\n    case '.yaml':\n      yaml.push(fileContent);\n      break;\n\n    case '.coffee':\n      regexResults = fileContent.match(csDocRegex) || [];\n      for (const result of regexResults) {\n        let part = result.split('###');\n        part[0] = `/**`;\n        part[part.length - 1] = '*/';\n        part = part.join('');\n        jsdoc.push(part);\n      }\n      break;\n\n    default: {\n      regexResults = fileContent.match(jsDocRegex) || [];\n      for (const result of regexResults) {\n        jsdoc.push(result);\n      }\n    }\n  }\n\n  return { yaml, jsdoc };\n}\n\n/**\n * @param {object} tag\n * @param {array} tags\n * @returns {boolean}\n */\nfunction isTagPresentInTags(tag, tags) {\n  const match = tags.find((targetTag) => tag.name === targetTag.name);\n  if (match) return true;\n\n  return false;\n}\n\n/**\n * Get an object of the definition file configuration.\n * @param {string} defPath\n * @param {object} swaggerDefinition\n */\nfunction loadDefinition(defPath, swaggerDefinition) {\n  const resolvedPath = path.resolve(defPath);\n  const extName = path.extname(resolvedPath);\n\n  // eslint-disable-next-line\n  const loadCjs = () => __webpack_require__(\"(rsc)/./node_modules/swagger-jsdoc/src sync recursive\")(resolvedPath);\n  const loadJson = () => JSON.parse(swaggerDefinition);\n  // eslint-disable-next-line\n  const loadYaml = () => (__webpack_require__(/*! yaml */ \"(rsc)/./node_modules/yaml/index.js\").parse)(swaggerDefinition);\n\n  const LOADERS = {\n    '.js': loadCjs, // on purpose, to allow throwing by nodejs and .cjs suggestion\n    '.cjs': loadCjs,\n    '.json': loadJson,\n    '.yml': loadYaml,\n    '.yaml': loadYaml,\n  };\n\n  const loader = LOADERS[extName];\n\n  if (loader === undefined) {\n    throw new Error('Definition file should be .cjs, .json, .yml or .yaml');\n  }\n\n  return loader();\n}\n\n/**\n * A recursive deep-merge that ignores null values when merging.\n * This returns the merged object and does not mutate.\n * @param {object} first the first object to get merged\n * @param {object} second the second object to get merged\n */\nfunction mergeDeep(first, second) {\n  return mergeWith({}, first, second, (a, b) => (b === null ? a : undefined));\n}\n\nmodule.exports.mergeDeep = mergeDeep;\nmodule.exports.convertGlobPaths = convertGlobPaths;\nmodule.exports.hasEmptyProperty = hasEmptyProperty;\nmodule.exports.extractYamlFromJsDoc = extractYamlFromJsDoc;\nmodule.exports.extractAnnotations = extractAnnotations;\nmodule.exports.isTagPresentInTags = isTagPresentInTags;\nmodule.exports.loadDefinition = loadDefinition;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dhZ2dlci1qc2RvYy9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQywrQ0FBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBa0I7O0FBRTVDO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDZFQUFRLFlBQVksQ0FBQztBQUM3QztBQUNBO0FBQ0EseUJBQXlCLDZFQUFxQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDZCQUE2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIYXJ5dTU0MTJcXERlc2t0b3BcXFNjaG9vbFxcY2Fwc3RvbmVcXHBpY3NlbFxcYmFja2VuZFxcbm9kZV9tb2R1bGVzXFxzd2FnZ2VyLWpzZG9jXFxzcmNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xuY29uc3QgbWVyZ2VXaXRoID0gcmVxdWlyZSgnbG9kYXNoLm1lcmdld2l0aCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGdsb2JzIHRvIGZ1bGwgcGF0aHNcbiAqIEBwYXJhbSB7YXJyYXl9IGdsb2JzIC0gQXJyYXkgb2YgZ2xvYnMgYW5kL29yIG5vcm1hbCBwYXRoc1xuICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCBwYXRoc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0R2xvYlBhdGhzKGdsb2JzKSB7XG4gIHJldHVybiBnbG9ic1xuICAgIC5tYXAoKGdsb2JTdHJpbmcpID0+IGdsb2Iuc3luYyhnbG9iU3RyaW5nKSlcbiAgICAucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gcHJldmlvdXMuY29uY2F0KGN1cnJlbnQpLCBbXSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZXJlIGlzIGFueSBwcm9wZXJ0aWVzIG9mIHRoZSBpbnB1dCBvYmplY3Qgd2hpY2ggYXJlIGFuIGVtcHR5IG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNFbXB0eVByb3BlcnR5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIC5tYXAoKGtleSkgPT4gb2JqW2tleV0pXG4gICAgLmV2ZXJ5KFxuICAgICAgKGtleU9iamVjdCkgPT5cbiAgICAgICAgdHlwZW9mIGtleU9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5T2JqZWN0KS5ldmVyeSgoa2V5KSA9PiAhKGtleSBpbiBrZXlPYmplY3QpKVxuICAgICk7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIFlBTUwgZGVzY3JpcHRpb24gZnJvbSBKU0RvYyBjb21tZW50cyB3aXRoIGBAc3dhZ2dlcmAvYEBvcGVuYXBpYCBhbm5vdGF0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IGpzRG9jQ29tbWVudCAtIFNpbmdsZSBpdGVtIG9mIEpTRG9jIGNvbW1lbnRzIGZyb20gZG9jdHJpbmUucGFyc2VcbiAqIEByZXR1cm5zIHthcnJheX0gWUFNTCBwYXJ0c1xuICovXG5mdW5jdGlvbiBleHRyYWN0WWFtbEZyb21Kc0RvYyhqc0RvY0NvbW1lbnQpIHtcbiAgY29uc3QgeWFtbFBhcnRzID0gW107XG5cbiAgZm9yIChjb25zdCB0YWcgb2YganNEb2NDb21tZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnLnRpdGxlID09PSAnc3dhZ2dlcicgfHwgdGFnLnRpdGxlID09PSAnb3BlbmFwaScpIHtcbiAgICAgIHlhbWxQYXJ0cy5wdXNoKHRhZy5kZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHlhbWxQYXJ0cztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGhcbiAqIEByZXR1cm5zIHt7anNkb2M6IGFycmF5LCB5YW1sOiBhcnJheX19IEpTRG9jIGNvbW1lbnRzIGFuZCBZYW1sIGZpbGVzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBbm5vdGF0aW9ucyhmaWxlUGF0aCwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgZmlsZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIHsgZW5jb2RpbmcgfSk7XG4gIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShmaWxlUGF0aCk7XG4gIGNvbnN0IGpzRG9jUmVnZXggPSAvXFwvXFwqXFwqKFtcXHNcXFNdKj8pXFwqXFwvL2dtO1xuICBjb25zdCBjc0RvY1JlZ2V4ID0gLyMjIyhbXFxzXFxTXSo/KSMjIy9nbTtcbiAgY29uc3QgeWFtbCA9IFtdO1xuICBjb25zdCBqc2RvYyA9IFtdO1xuICBsZXQgcmVnZXhSZXN1bHRzID0gbnVsbDtcblxuICBzd2l0Y2ggKGV4dCkge1xuICAgIGNhc2UgJy55bWwnOlxuICAgIGNhc2UgJy55YW1sJzpcbiAgICAgIHlhbWwucHVzaChmaWxlQ29udGVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJy5jb2ZmZWUnOlxuICAgICAgcmVnZXhSZXN1bHRzID0gZmlsZUNvbnRlbnQubWF0Y2goY3NEb2NSZWdleCkgfHwgW107XG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZWdleFJlc3VsdHMpIHtcbiAgICAgICAgbGV0IHBhcnQgPSByZXN1bHQuc3BsaXQoJyMjIycpO1xuICAgICAgICBwYXJ0WzBdID0gYC8qKmA7XG4gICAgICAgIHBhcnRbcGFydC5sZW5ndGggLSAxXSA9ICcqLyc7XG4gICAgICAgIHBhcnQgPSBwYXJ0LmpvaW4oJycpO1xuICAgICAgICBqc2RvYy5wdXNoKHBhcnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZWdleFJlc3VsdHMgPSBmaWxlQ29udGVudC5tYXRjaChqc0RvY1JlZ2V4KSB8fCBbXTtcbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlZ2V4UmVzdWx0cykge1xuICAgICAgICBqc2RvYy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgeWFtbCwganNkb2MgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFnXG4gKiBAcGFyYW0ge2FycmF5fSB0YWdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUYWdQcmVzZW50SW5UYWdzKHRhZywgdGFncykge1xuICBjb25zdCBtYXRjaCA9IHRhZ3MuZmluZCgodGFyZ2V0VGFnKSA9PiB0YWcubmFtZSA9PT0gdGFyZ2V0VGFnLm5hbWUpO1xuICBpZiAobWF0Y2gpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IG9mIHRoZSBkZWZpbml0aW9uIGZpbGUgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZQYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3dhZ2dlckRlZmluaXRpb25cbiAqL1xuZnVuY3Rpb24gbG9hZERlZmluaXRpb24oZGVmUGF0aCwgc3dhZ2dlckRlZmluaXRpb24pIHtcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcGF0aC5yZXNvbHZlKGRlZlBhdGgpO1xuICBjb25zdCBleHROYW1lID0gcGF0aC5leHRuYW1lKHJlc29sdmVkUGF0aCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGNvbnN0IGxvYWRDanMgPSAoKSA9PiByZXF1aXJlKHJlc29sdmVkUGF0aCk7XG4gIGNvbnN0IGxvYWRKc29uID0gKCkgPT4gSlNPTi5wYXJzZShzd2FnZ2VyRGVmaW5pdGlvbik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb25zdCBsb2FkWWFtbCA9ICgpID0+IHJlcXVpcmUoJ3lhbWwnKS5wYXJzZShzd2FnZ2VyRGVmaW5pdGlvbik7XG5cbiAgY29uc3QgTE9BREVSUyA9IHtcbiAgICAnLmpzJzogbG9hZENqcywgLy8gb24gcHVycG9zZSwgdG8gYWxsb3cgdGhyb3dpbmcgYnkgbm9kZWpzIGFuZCAuY2pzIHN1Z2dlc3Rpb25cbiAgICAnLmNqcyc6IGxvYWRDanMsXG4gICAgJy5qc29uJzogbG9hZEpzb24sXG4gICAgJy55bWwnOiBsb2FkWWFtbCxcbiAgICAnLnlhbWwnOiBsb2FkWWFtbCxcbiAgfTtcblxuICBjb25zdCBsb2FkZXIgPSBMT0FERVJTW2V4dE5hbWVdO1xuXG4gIGlmIChsb2FkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVmaW5pdGlvbiBmaWxlIHNob3VsZCBiZSAuY2pzLCAuanNvbiwgLnltbCBvciAueWFtbCcpO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRlcigpO1xufVxuXG4vKipcbiAqIEEgcmVjdXJzaXZlIGRlZXAtbWVyZ2UgdGhhdCBpZ25vcmVzIG51bGwgdmFsdWVzIHdoZW4gbWVyZ2luZy5cbiAqIFRoaXMgcmV0dXJucyB0aGUgbWVyZ2VkIG9iamVjdCBhbmQgZG9lcyBub3QgbXV0YXRlLlxuICogQHBhcmFtIHtvYmplY3R9IGZpcnN0IHRoZSBmaXJzdCBvYmplY3QgdG8gZ2V0IG1lcmdlZFxuICogQHBhcmFtIHtvYmplY3R9IHNlY29uZCB0aGUgc2Vjb25kIG9iamVjdCB0byBnZXQgbWVyZ2VkXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVlcChmaXJzdCwgc2Vjb25kKSB7XG4gIHJldHVybiBtZXJnZVdpdGgoe30sIGZpcnN0LCBzZWNvbmQsIChhLCBiKSA9PiAoYiA9PT0gbnVsbCA/IGEgOiB1bmRlZmluZWQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMubWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xubW9kdWxlLmV4cG9ydHMuY29udmVydEdsb2JQYXRocyA9IGNvbnZlcnRHbG9iUGF0aHM7XG5tb2R1bGUuZXhwb3J0cy5oYXNFbXB0eVByb3BlcnR5ID0gaGFzRW1wdHlQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzLmV4dHJhY3RZYW1sRnJvbUpzRG9jID0gZXh0cmFjdFlhbWxGcm9tSnNEb2M7XG5tb2R1bGUuZXhwb3J0cy5leHRyYWN0QW5ub3RhdGlvbnMgPSBleHRyYWN0QW5ub3RhdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5pc1RhZ1ByZXNlbnRJblRhZ3MgPSBpc1RhZ1ByZXNlbnRJblRhZ3M7XG5tb2R1bGUuZXhwb3J0cy5sb2FkRGVmaW5pdGlvbiA9IGxvYWREZWZpbml0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swagger-jsdoc/src/utils.js\n");

/***/ })

};
;